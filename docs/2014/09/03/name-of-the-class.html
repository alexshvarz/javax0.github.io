<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Name of the class | Java Deep, mostly Java</title>
<meta name="generator" content="Jekyll v4.3.1" />
<meta property="og:title" content="Name of the class" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In Java every class has a name. Classes are in packages and this lets us programmers work together avoiding name collision. I can name my class A and you can also name your class A so long as long they are in different packages, they work together fine." />
<meta property="og:description" content="In Java every class has a name. Classes are in packages and this lets us programmers work together avoiding name collision. I can name my class A and you can also name your class A so long as long they are in different packages, they work together fine." />
<link rel="canonical" href="https://javax0.github.io/2014/09/03/name-of-the-class.html" />
<meta property="og:url" content="https://javax0.github.io/2014/09/03/name-of-the-class.html" />
<meta property="og:site_name" content="Java Deep, mostly Java" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2014-09-03T00:00:00+02:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Name of the class" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2014-09-03T00:00:00+02:00","datePublished":"2014-09-03T00:00:00+02:00","description":"In Java every class has a name. Classes are in packages and this lets us programmers work together avoiding name collision. I can name my class A and you can also name your class A so long as long they are in different packages, they work together fine.","headline":"Name of the class","mainEntityOfPage":{"@type":"WebPage","@id":"https://javax0.github.io/2014/09/03/name-of-the-class.html"},"url":"https://javax0.github.io/2014/09/03/name-of-the-class.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://javax0.github.io/feed.xml" title="Java Deep, mostly Java" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Java Deep, mostly Java</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/">Java Deep</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Name of the class</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2014-09-03T00:00:00+02:00" itemprop="datePublished">Sep 3, 2014
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <div class="paragraph">
<p>In Java every class has a name. Classes are in packages and this lets us programmers work together avoiding name collision. I can name my class <code>A</code> and you can also name your class <code>A</code> so long as long they are in different packages, they work together fine.</p>
</div>
<div class="paragraph">
<p>If you looked at the API of the class <code>Class</code> you certainly noticed that there are three different methods that give you the name of a class:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>getSimpleName()</code> gives you the name of the class without the package.</p>
</li>
<li>
<p><code>getName()</code> gives you the name of the class with the full package name in front.</p>
</li>
<li>
<p><code>getCanonicalName()</code> gives you the canonical name of the class.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Simple is it? Well, the first is simple and the second is also meaningful unless there is that disturbing canonical name. That is not evident what that is. And if you do not know what canonical name is, you may feel some disturbance in the force of your Java skills for the second also. What is the difference between the two?</p>
</div>
<div class="paragraph">
<p>If you want a precise explanation, visit the <a href="http://docs.oracle.com/javase/specs/jls/se8/html/jls-6.html#jls-6.7">chapter 6.7 of Java Language Specification</a>. Here we go with something simpler, aimed simpler to understand though not so thorough.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s see some examples:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">package pakage.subpackage.evensubberpackage;
import org.junit.Assert;
import org.junit.Test;

public class WhatIsMyName {
	@Test
	public void classHasName() {
		final Class&lt;?&gt; klass = WhatIsMyName.class;
		final String simpleNameExpected = "WhatIsMyName";
		Assert.assertEquals(simpleNameExpected, klass.getSimpleName());
		final String nameExpected = "pakage.subpackage.evensubberpackage.WhatIsMyName";
		Assert.assertEquals(nameExpected, klass.getName());
		Assert.assertEquals(nameExpected, klass.getCanonicalName());
	}
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>This "unit test" just runs fine. But as you can see there is no difference between name and canonical name in this case. (Note that the name of the package is <code>pakage</code> and not <code>package</code>. To test your java lexical skills answer the question why?)</p>
</div>
<div class="paragraph">
<p>Let&#8217;s have a look at the next example from the same junit test file:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">	@Test
	public void arrayHasName() {
		final Class&lt;?&gt; klass = WhatIsMyName[].class;
		final String simpleNameExpected = "WhatIsMyName[]";
		Assert.assertEquals(simpleNameExpected, klass.getSimpleName());
		final String nameExpected = "[Lpakage.subpackage.evensubberpackage.WhatIsMyName;";
		Assert.assertEquals(nameExpected, klass.getName());
		final String canonicalNameExpected = "pakage.subpackage.evensubberpackage.WhatIsMyName[]";
		Assert.assertEquals(canonicalNameExpected, klass.getCanonicalName());
	}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Now there are differences. When we talk about arrays the simple name signals it appending the opening and closing brackets, just like we would do in Java source code. The "normal" name looks a bit weird. It starts with an <code>L</code> and semicolon is appended. This reflects the internal representation of the class names in the JVM. The canonical name changed similar to the simple name: it is the same as before for the class having all the package names as prefix with the brackets appended. Seems that <code>getName()</code> is more the JVM name of the class and <code>getCanonicalName()</code> is more like the fully qualified name on Java source level.</p>
</div>
<div class="paragraph">
<p>Let&#8217;s go on with still some other example (we are still in the same file):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">	class NestedClass{}

	@Test
	public void nestedClassHasName() {
		final Class&lt;?&gt; klass = NestedClass.class;
		final String simpleNameExpected = "NestedClass";
		Assert.assertEquals(simpleNameExpected, klass.getSimpleName());
		final String nameExpected = "pakage.subpackage.evensubberpackage.WhatIsMyName$NestedClass";
		Assert.assertEquals(nameExpected, klass.getName());
		final String canonicalNameExpected = "pakage.subpackage.evensubberpackage.WhatIsMyName.NestedClass";
		Assert.assertEquals(canonicalNameExpected, klass.getCanonicalName());
	}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The difference is the dollar sign in the name of the class. Again the "name" is more what is used by the JVM and canonical name is what is Java source code like. If you compile this code, the Java compiler will generate the files:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>WhatIsMyName.class</code> and</p>
</li>
<li>
<p><code>WhatIsMyName$NestedClass.class</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Even though the class is named nested class it actually is an inner class. However in the naming there is no difference: a static or non-static class inside another class is just named the same. Now let&#8217;s see something even more interesting:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">	@Test
	public void methodClassHasName() {
		class MethodClass{};
		final Class&lt;?&gt; klass = MethodClass.class;
		final String simpleNameExpected = "MethodClass";
		Assert.assertEquals(simpleNameExpected, klass.getSimpleName());
		final String nameExpected = "pakage.subpackage.evensubberpackage.WhatIsMyName$1MethodClass";
		Assert.assertEquals(nameExpected, klass.getName());
		final String canonicalNameExpected = null;
		Assert.assertEquals(canonicalNameExpected, klass.getCanonicalName());
	}</code></pre>
</div>
</div>
<div class="paragraph">
<p>This time we have a class inside a method. Not a usual scenario, but valid from the Java language point of view. The simple name of the class is just that: the simple name of the class. No much surprise.</p>
</div>
<div class="paragraph">
<p>The "normal" name however is interesting. The Java compiler generates a JVM name for the class and this name contains a number in it. Why? Because nothing would stop me having a class with the same name in another method in our test class and inserting a number is the way to prevent name collisions for the JVM. The JVM does not know or care anything about inner and nested classes or classes defined inside a method. A class is just a class. If you compile the code you will probably see the file <code>WhatIsMyName$1MethodClass.class</code> generated by javac. I had to add "probably" not because I count the possibility of you being blind, but rather because this name is actually the internal matter of the Java compiler. It may choose different name collision avoiding strategy, though I know no compiler that differs from the above.</p>
</div>
<div class="paragraph">
<p>The canonical name is the most interesting. It does not exist! It is null. Why? Because you can not access this class from outside the method defining it. It does not have a canonical name. Let&#8217;s go on.</p>
</div>
<div class="paragraph">
<p>What about anonymous classes. They should not have name. After all, that is why they are called anonymous.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">	@Test
	public void anonymousClassHasName() {
		final Class&lt;?&gt; klass = new Object(){}.getClass();
		final String simpleNameExpected = "";
		Assert.assertEquals(simpleNameExpected, klass.getSimpleName());
		final String nameExpected = "pakage.subpackage.evensubberpackage.WhatIsMyName$1";
		Assert.assertEquals(nameExpected, klass.getName());
		final String canonicalNameExpected = null;
		Assert.assertEquals(canonicalNameExpected, klass.getCanonicalName());
	}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Actually they do not have simple name. The simple name is empty string. They do, however have name, made up by the compiler. Poor javac does not have other choice. It has to make up some name even for the unnamed classes. It has to generate the code for the JVM and it has to save it to some file. Canonical name is again null.</p>
</div>
<div class="paragraph">
<p>Are we ready with the examples? No. We have something simple (a.k.a. primitive) at the end. Java primitives.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">	@Test
	public void intClassHasName() {
		final Class&lt;?&gt; klass = int.class;
		final String intNameExpected = "int";
		Assert.assertEquals(intNameExpected, klass.getSimpleName());
		Assert.assertEquals(intNameExpected, klass.getName());
		Assert.assertEquals(intNameExpected, klass.getCanonicalName());
	}</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the class represents a primitive, like <code>int</code> (what can be simpler than an int?) then the simple name, "the" name and the canonical names are all <code>int</code> the name of the primitive.</p>
</div>
<div class="paragraph">
<p>Just as well an array of a primitive is very simple is it?</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">	@Test
	public void intArrayClassHasName() {
		final Class&lt;?&gt; klass = int[].class;
		final String simpleNameExpected = "int[]";
		Assert.assertEquals(simpleNameExpected, klass.getSimpleName());
		final String nameExpected = "[I";
		Assert.assertEquals(nameExpected, klass.getName());
		final String canonicalNameExpected = "int[]";
		Assert.assertEquals(canonicalNameExpected, klass.getCanonicalName());
	}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Well, it is not simple. The name is <code>[I</code>, which is a bit mysterious unless you read the <a href="http://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.3">respective chapter</a> of the JVM specification. Perhaps I talk about that another time.</p>
</div>
<div class="sect1">
<h2 id="1-conclusion">1. Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The simple name of the class is simple. The "name" returned by <code>getName()</code> is the one interesting for JVM level things. The <code>getCanonicalName()</code> is the one that looks most like Java source.</p>
</div>
<div class="paragraph">
<p>You can get the full source code of the example above from the gist <a href="https://gist.github.com/verhas/e789d700d3c9abc6afa0">e789d700d3c9abc6afa0</a> from GitHub.</p>
</div>
<div class="sect2">
<h3 id="comments-imported-from-wordpress">Comments imported from Wordpress</h3>
<div class="paragraph">
<p><strong>Peter Verhas</strong> 2014-09-04 09:02:42</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Yes. That is exactly what the sample code shows.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p><strong>ArrrA</strong> 2014-09-03 23:14:00</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Interesting entry. I don&#8217;t recall well, but when i used anonymous classes, i believe simpleName returned empty</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p><strong>When null checking miserably fails | Java Deep</strong> 2014-11-05 10:00:59</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>[&#8230;] method toString() in class Object has a return type java.lang.String. You may want to read my article about the difference between the name, simple name and canonical name of a class. It may shed some [&#8230;]</p>
</div>
</blockquote>
</div>
</div>
</div>
</div>


<!-- Disqus comments section goes here (if comments are enabled) -->

<hr/>
<h1>Comments</h1>
<p>Please leave your comments using Disqus, or just press one of the happy faces.
If for any reason you do not want to leave a comment here, <a href="https://github.com/javax0/javax0.github.io/issues">you can still create a Github ticket</a>.</p>
<div class="comments">
    <div id="disqus_thread"></div>

    <script type="text/javascript">

        /* * * STOP! * * */
        /* You shouldn't need to edit ANYTHING below to get this working! */
        /* Instead, edit the key `disqus.shortname` in _config.yml */

        var disqus_config = function (){
            this.page.url = 'https://javax0.github.io/2014/09/03/name-of-the-class.html';
            this.page.identifier = '/2014/09/03/name-of-the-class.html';
        };

        (function() {
            var d = document, s = d.createElement('script');
            s.type = 'text/javascript'; s.async = true;
            s.src = 'https://javax0.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();

    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>




  </div><a class="u-url" href="/2014/09/03/name-of-the-class.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Java Deep, mostly Java</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Java Deep, mostly Java</li><li><a class="u-email" href="mailto:peter@verhas.com">peter@verhas.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/verhas"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">verhas</span></a></li><li><a href="https://www.twitter.com/verhas"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">verhas</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>javax0 is a technical Java oriented blog. Whenever I find something interesting, in the mood and feel the power to publish it, you will get it here. Publications are usually released on Wednesday 15:00am GMT. Earlier posts of the blog were published on Javax0 Wordpress Site at https://javax0.wordpress.com</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
