<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Semantic versioning is a simplification | Java Deep, mostly Java</title>
<meta name="generator" content="Jekyll v4.3.1" />
<meta property="og:title" content="Semantic versioning is a simplification" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Semantic version seems to become a de facto standard in the industry. This is very good since the versioning of software packages is very important when we want to compare two versions and decide which one to use. Without semantic versioning you have to consult the documentation to decide if you can upgrade the use library from version 1.34 to 1.36. When you rely on semantic versioning the answer is simple (in theory): yes, you can. Version 1.36 has to be backward compatible with version 1.34 Decision is as easy as saying it out loud and then the time saved can be used for some more precious work that needs brain. In practice there may be some problem, but in that case the basic assumption, semver was used, turns out to be false." />
<meta property="og:description" content="Semantic version seems to become a de facto standard in the industry. This is very good since the versioning of software packages is very important when we want to compare two versions and decide which one to use. Without semantic versioning you have to consult the documentation to decide if you can upgrade the use library from version 1.34 to 1.36. When you rely on semantic versioning the answer is simple (in theory): yes, you can. Version 1.36 has to be backward compatible with version 1.34 Decision is as easy as saying it out loud and then the time saved can be used for some more precious work that needs brain. In practice there may be some problem, but in that case the basic assumption, semver was used, turns out to be false." />
<link rel="canonical" href="https://javax0.github.io/2013/11/27/semantic-versioning-is-a-simplification.html" />
<meta property="og:url" content="https://javax0.github.io/2013/11/27/semantic-versioning-is-a-simplification.html" />
<meta property="og:site_name" content="Java Deep, mostly Java" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2013-11-27T00:00:00+01:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Semantic versioning is a simplification" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2013-11-27T00:00:00+01:00","datePublished":"2013-11-27T00:00:00+01:00","description":"Semantic version seems to become a de facto standard in the industry. This is very good since the versioning of software packages is very important when we want to compare two versions and decide which one to use. Without semantic versioning you have to consult the documentation to decide if you can upgrade the use library from version 1.34 to 1.36. When you rely on semantic versioning the answer is simple (in theory): yes, you can. Version 1.36 has to be backward compatible with version 1.34 Decision is as easy as saying it out loud and then the time saved can be used for some more precious work that needs brain. In practice there may be some problem, but in that case the basic assumption, semver was used, turns out to be false.","headline":"Semantic versioning is a simplification","mainEntityOfPage":{"@type":"WebPage","@id":"https://javax0.github.io/2013/11/27/semantic-versioning-is-a-simplification.html"},"url":"https://javax0.github.io/2013/11/27/semantic-versioning-is-a-simplification.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="https://javax0.github.io/feed.xml" title="Java Deep, mostly Java" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Java Deep, mostly Java</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/">Java Deep</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Semantic versioning is a simplification</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2013-11-27T00:00:00+01:00" itemprop="datePublished">Nov 27, 2013
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <div class="paragraph">
<p><a href="http://semver.org/">Semantic version</a> seems to become a de facto standard in the industry. This is very good since the versioning of software packages is very important when we want to compare two versions and decide which one  to use. Without semantic versioning you have to consult the documentation to decide if you can upgrade the use library from version 1.34 to 1.36. When you rely on semantic versioning the answer is simple (in theory): yes, you can. Version 1.36 has to be backward compatible with version 1.34 Decision is as easy as saying it out loud and then the time saved can be used for some more precious work that needs brain. In practice there may be some problem, but in that case the basic assumption, semver was used, turns out to be false.</p>
</div>
<div class="paragraph">
<p>How can we tell that 1.36 is backward compatible with version 1.34? That comes from the definition of semantic versioning. The <code>M.m.p</code> scheme, Major, minor, patch, says that Major versions introduce incompatible change, minor compatible change and patch is what the name says: bug fix.</p>
</div>
<div class="paragraph">
<p>You can notice that <code>M</code> and <code>m</code> talks about the <em>specification</em> of the library, while <code>p</code> about the <em>implementation</em> . There is nothing new about this. Java SE documentation contains a <a href="http://docs.oracle.com/javase/tutorial/deployment/jar/packageman.html">chapter</a> about product versioning. The chapter talks about how to version packages, and recommends to use separate specification and implementation versions. The versions are defined in the manifest file in the JAR file that contains the package. Specification version is recommended to have the form <code>major.minor.micro</code>. There is no recommendation for the implementation version. A sample manifest file looks:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">Manifest-version: 1.0

Name: java/util/
Specification-Title: "Java Utility Classes"
Specification-Version: "1.2"
Specification-Vendor: "Sun Microsystems Inc."
Package-Title: "java.util"
Package-Version: "build57"
Package-Vendor: "Sun Microsystems. Inc."</code></pre>
</div>
</div>
<div class="paragraph">
<p>Semantic versioning as an approach is compatible with this. Semver does not support micro versions for the specification, only major and minor, but after all the ORACLE/SUN documentation itself does not say too much about the micro: <em> major version numbers identify significant functional changes, minor version numbers identify smaller extensions to the functionality, micro versions are even finer grained versions.</em> Even finer grained. That is all about it. Do we need that? My suggestion is: not. And this is the implicit suggestion of semver.</p>
</div>
<div class="paragraph">
<p>Einstein <a href="http://quoteinvestigator.com/2011/05/13/einstein-simple/">allegedly</a> said: <em>Everything should be made as simple as possible, but not simpler.</em></p>
</div>
<div class="paragraph">
<p>This is the case of semantic versioning and Java package versioning. As time proved, Java packaging versioning is simply not simple. It is too complex to be practical and real life versioning problems do not need this level of complexity. Other versioning approaches may be too simple and at the end of the day semver may just fit the purpose.</p>
</div>
<div class="paragraph">
<p>Maven is a huge supporter of semantic versioning and the <a href="http://maven.apache.org/shared/maven-archiver/index.html">archiver plugin</a> helps you to include the versions into the manifest file so that your package is compatible with the Java SE recommendation and Java RT can query the version of a package. The version of your library is specified in the <code>pom.xml</code> file and this version is used when creating the manifest.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">Implementation-Title: ${project.name}
Implementation-Version: ${project.version}
Implementation-Vendor-Id: ${project.groupId}
Implementation-Vendor: ${project.organization.name}

Specification-Title: ${project.name}
Specification-Version: ${project.version}
Specification-Vendor: ${project.organization.name}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Interesting that both the specification and the implementation version contains the whole package version. The semantic version compatible solution would be to include only the <code>M.m</code> version in the specification version and either the whole version number or only the rest for the implementation version.</p>
</div>
<div class="sect2">
<h3 id="comments-imported-from-wordpress">Comments imported from Wordpress</h3>
<div class="paragraph">
<p><strong>Verhás István</strong> 2013-11-28 12:50:10</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>At first the missing link for product versioning is <a href="http://docs.oracle.com/javase/7/docs/technotes/guides/versioning/spec/versioning2.html" class="bare">http://docs.oracle.com/javase/7/docs/technotes/guides/versioning/spec/versioning2.html</a>. The documentation is confused and therefore the quoted part in this blog also. It calls Package-* properties instead of Implementation-* ones. On the other hand in the maven example and also the offical tutorial changes into Implementation-* properties. To make it clear i have created a sample MANIFEST.MF and a very short App:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>MANIFEST.MF
Manifest-version: 1.0

Name: sandbox/
Specification-Title: "Java Utility Classes"
Specification-Version: "1.2"
Specification-Vendor: "Sun Microsystems Inc."
Package-Title: "java.util"
Package-Version: "build57"
Package-Vendor: "Sun Microsystems. Inc."
Implementation-Title: ${project.name}
Implementation-Version: ${project.version}
Implementation-Vendor-Id: ${project.groupId}
Implementation-Vendor: ${project.organization.name}</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>App.java</code></p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>package sandbox;

public class App {

    public static void main(String[] args) {
        Package thisPackage = Package.getPackage("sandbox");

        System.out.println("thisPackage.getImplementationVersion()=" + thisPackage.getImplementationVersion());
        System.out.println("thisPackage.getSpecificationVersion()=" + thisPackage.getSpecificationVersion());
    }
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>after building the result is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>verhasi$ java -cp target/sandbox-1.0.0-SNAPSHOT.jar sandbox.App
thisPackage.getImplementationVersion()=1.0.0-SNAPSHOT
thisPackage.getSpecificationVersion()="1.2"
verhasi$ java -version
java version "1.7.0_21"
Java(TM) SE Runtime Environment (build 1.7.0_21-b12)
Java HotSpot(TM) 64-Bit Server VM (build 23.21-b01, mixed mode)
verhasi$</code></pre>
</div>
</div>
<div class="paragraph">
<p>As a conclusion we can state that at least this version of java uses the Implementation-* properties in the Package class returning getImplementationVersion(). I have filed it as a bug at <a href="http://bugreport.sun.com/bugreport" class="bare">http://bugreport.sun.com/bugreport</a> Bug Id: 9008521.</p>
</div>
</blockquote>
</div>
</div>


<!-- Disqus comments section goes here (if comments are enabled) -->

<hr/>
<h1>Comments</h1>
<p>Please leave your comments using Disqus, or just press one of the happy faces.
If for any reason you do not want to leave a comment here, <a href="https://github.com/javax0/javax0.github.io/issues">you can still create a Github ticket</a>.</p>
<div class="comments">
    <div id="disqus_thread"></div>

    <script type="text/javascript">

        /* * * STOP! * * */
        /* You shouldn't need to edit ANYTHING below to get this working! */
        /* Instead, edit the key `disqus.shortname` in _config.yml */

        var disqus_config = function (){
            this.page.url = 'https://javax0.github.io/2013/11/27/semantic-versioning-is-a-simplification.html';
            this.page.identifier = '/2013/11/27/semantic-versioning-is-a-simplification.html';
        };

        (function() {
            var d = document, s = d.createElement('script');
            s.type = 'text/javascript'; s.async = true;
            s.src = 'https://javax0.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();

    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>




  </div><a class="u-url" href="/2013/11/27/semantic-versioning-is-a-simplification.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Java Deep, mostly Java</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Java Deep, mostly Java</li><li><a class="u-email" href="mailto:peter@verhas.com">peter@verhas.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/verhas"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">verhas</span></a></li><li><a href="https://www.twitter.com/verhas"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">verhas</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>javax0 is a technical Java oriented blog. Whenever I find something interesting, in the mood and feel the power to publish it, you will get it here. Publications are usually released on Wednesday 15:00am GMT. Earlier posts of the blog were published on Javax0 Wordpress Site at https://javax0.wordpress.com</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
