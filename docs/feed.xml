<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.1">Jekyll</generator><link href="https://javax0.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://javax0.github.io/" rel="alternate" type="text/html" /><updated>2023-01-25T11:37:00+01:00</updated><id>https://javax0.github.io/feed.xml</id><title type="html">Java Deep, mostly Java</title><subtitle>javax0 is a technical Java oriented blog. Whenever I find something interesting, in the mood and feel the power to publish it, you will get it here. Publications are usually released on Wednesday 15:00am GMT. Earlier posts of the blog were published on Javax0 Wordpress Site at https://javax0.wordpress.com</subtitle><entry><title type="html">Ten Useless Things You Did Not Know About Java</title><link href="https://javax0.github.io/2023/01/23/ten-java.html" rel="alternate" type="text/html" title="Ten Useless Things You Did Not Know About Java" /><published>2023-01-23T00:00:00+01:00</published><updated>2023-01-23T00:00:00+01:00</updated><id>https://javax0.github.io/2023/01/23/ten-java</id><content type="html" xml:base="https://javax0.github.io/2023/01/23/ten-java.html">[%collapsible,title=Article Management Technical Details]
====
****
* Code link:https://github.com/javax0/javax0.github.io/tree/master/_projects/2023-01-23-ten-java[https://github.com/javax0/javax0.github.io/tree/master/_projects/2023-01-23-ten-java]
* Article source link:https://github.com/javax0/javax0.github.io/blob/master/_posts/2023-01-23-ten-java.adoc.jam[https://github.com/javax0/javax0.github.io/blob/master/_posts/2023-01-23-ten-java.adoc.jam]
****
====

Java is a complex language, and some features that initially seemed a good idea turned out to be useless.
In this article, we will look at ten such Java language features.

== 1. Java Has Labels

You can have labels in your Java code.

[source,java]
----
 1.         LABEL1:
 2.         for (int i = 0; i &lt; 10; i++) {
 3.             for (int j = 0; j &lt; 10; j++) {
 4.                 if (i * j &gt; 15 &amp;&amp; (i * j) % 2 == 0) break LABEL1;
 5.                 System.out.print(&quot;%d,%d &quot;.formatted(i, j));
 6.             }
 7.             System.out.println();
 8.         }
 9.         System.out.println();
10.         System.out.println();
11.         LABEL2:
12.         for (int i = 0; i &lt; 10; i++) {
13.             for (int j = 0; j &lt; 10; j++) {
14.                 if (i * j &gt; 15 &amp;&amp; (i * j) % 2 == 0) {
15.                     System.out.println();
16.                     continue LABEL2;
17.                 }
18.                 System.out.print(&quot;%d,%d &quot;.formatted(i, j));
19.             }
20.             System.out.println();
21.         }

----

Like you could have them in assembly.
Or when you were programming BASIC numbering the lines.

To interrupt an outer loop, you can reference these labels in the `break` or `continue` command.

The output of the above program is:
[source,text]
----
0,0 0,1 0,2 0,3 0,4 0,5 0,6 0,7 0,8 0,9 
1,0 1,1 1,2 1,3 1,4 1,5 1,6 1,7 1,8 1,9 
2,0 2,1 2,2 2,3 2,4 2,5 2,6 2,7 

0,0 0,1 0,2 0,3 0,4 0,5 0,6 0,7 0,8 0,9 
1,0 1,1 1,2 1,3 1,4 1,5 1,6 1,7 1,8 1,9 
2,0 2,1 2,2 2,3 2,4 2,5 2,6 2,7 
3,0 3,1 3,2 3,3 3,4 3,5 
4,0 4,1 4,2 4,3 
5,0 5,1 5,2 5,3 
6,0 6,1 6,2 
7,0 7,1 7,2 7,3 
8,0 8,1 
9,0 9,1 

----

If you want to compare, here is the version without the labels:

[%collapsible, title=&quot;Click to open the version without labels&quot;]
====
[source,java]
----
 1.         for (int i = 0; i &lt; 10; i++) {
 2.             for (int j = 0; j &lt; 10; j++) {
 3.                 if (i * j &gt; 15 &amp;&amp; (i * j) % 2 == 0) break;
 4.                 System.out.print(&quot;%d,%d &quot;.formatted(i, j));
 5.             }
 6.             System.out.println();
 7.         }
 8.         System.out.println();
 9.         System.out.println();
10.         for (int i = 0; i &lt; 10; i++) {
11.             for (int j = 0; j &lt; 10; j++) {
12.                 if (i * j &gt; 15 &amp;&amp; (i * j) % 2 == 0) {
13.                     System.out.println();
14.                     continue;
15.                 }
16.                 System.out.print(&quot;%d,%d &quot;.formatted(i, j));
17.             }
18.             System.out.println();
19.         }

----

and the output

[source,text]
----
0,0 0,1 0,2 0,3 0,4 0,5 0,6 0,7 0,8 0,9 
1,0 1,1 1,2 1,3 1,4 1,5 1,6 1,7 1,8 1,9 
2,0 2,1 2,2 2,3 2,4 2,5 2,6 2,7 
3,0 3,1 3,2 3,3 3,4 3,5 
4,0 4,1 4,2 4,3 
5,0 5,1 5,2 5,3 
6,0 6,1 6,2 
7,0 7,1 7,2 7,3 
8,0 8,1 
9,0 9,1 


0,0 0,1 0,2 0,3 0,4 0,5 0,6 0,7 0,8 0,9 
1,0 1,1 1,2 1,3 1,4 1,5 1,6 1,7 1,8 1,9 
2,0 2,1 2,2 2,3 2,4 2,5 2,6 2,7 


3,0 3,1 3,2 3,3 3,4 3,5 
3,7 
3,9 
4,0 4,1 4,2 4,3 






5,0 5,1 5,2 5,3 
5,5 
5,7 
5,9 
6,0 6,1 6,2 







7,0 7,1 7,2 7,3 
7,5 
7,7 
7,9 
8,0 8,1 








9,0 9,1 
9,3 
9,5 
9,7 
9,9 

----
====

== 2. You can `break` from a Block

Labels make it possible to break from a block.
It does not need to be a loop.

[source,java]
----
 1.         for (int i = 1; i &lt;= 15; i++) {
 2.             FIZZ:
 3.             {
 4.                 System.out.printf(&quot;%d &quot;, i);
 5.                 if (i % 3 != 0) break FIZZ;
 6.                 System.out.print(&quot;fiz&quot;);
 7.             }
 8.             BUZZ:
 9.             {
10.                 if (i % 5 != 0) break BUZZ;
11.                 System.out.print(&quot;buzz&quot;);
12.             }
13.             System.out.println();
14.         }

----

It will print

[source,text]
----
1 
2 
3 fiz
4 
5 buzz
6 fiz
7 
8 
9 fiz
10 buzz
11 
12 fiz
13 
14 
15 fizbuzz

----

== 3. `static` Methods can also be `final`

When a method is final in a class, you cannot redefine it in a child class.
Static methods, however, are not virtual.
They cannot be redefined.
A static method in the child class of the same signature has nothing to do with the method in the parent class.
Or does it?

Actually, it does.
If the static method is `final`, then the child class cannot have a method with the same signature.

To demonstrate this, we compile the test classes dynamically.
We do not want any syntax errors in our demo project.

[source,java]
----
 1.         final var FIZZ = &quot;&quot;&quot;
 2.                 package com.javax0.blog.tenjava;
 3.                 public class Fizz {
 4.                     static void fizzy(){
 5.                     }
 6.                 }
 7.                 &quot;&quot;&quot;;
 8.         final var BUZZ = &quot;&quot;&quot;
 9.                 package com.javax0.blog.tenjava;
10.                 public class Buzz extends Fizz {
11.                     static void fizzy(){
12.                     }
13.                 }
14.                 &quot;&quot;&quot;;
15.         final var testSet1 = Compiler.java().from(
16.                 FIZZ
17.         ).from(BUZZ).compile().load();
18.         testSet1.get(&quot;Buzz&quot;);
19.         Assertions.assertThrows(Compiler.CompileException.class, () -&gt; Compiler.java().from(
20.                 FIZZ.replaceAll(&quot;static void&quot;, &quot;final static void&quot;)
21.         ).from(BUZZ).compile());

----

We compile FIZZ and BUZZ.
Both classes have a method named `fizzy()`.
No problem.
Then we change the method in the class `Fizz` to `final`.
Now the compilation fails.

You cannot &quot;override&quot; the final method.

== 4. `goto` is a reserved word

There is no `goto` in Java; still, &apos; goto` is a keyword.
The designers of the language thought it to be a good idea.
Future versions of Java may have a `goto` statement.
Let&apos;s reserve this as a keyword.

[source,java]
----
 1.         Compiler.java().from(&quot;&quot;&quot;
 2.                 package com.javax0.blog.tenjava;
 3.                 class NoGotoPlease{
 4.                   public void _goto(){
 5.                   }
 6.                 }
 7.                 &quot;&quot;&quot;
 8.         ).compile();
 9.         Assertions.assertThrows(Compiler.CompileException.class, () -&gt; Compiler.java().from(&quot;&quot;&quot;
10.                 package com.javax0.blog.tenjava;
11.                 class NoGotoPlease{
12.                   public void goto(){
13.                   }
14.                 }
15.                 &quot;&quot;&quot;
16.         ).compile());

----

If we name the method `_goto`, it is okay.
Using it without an underscore in the front: it is a keyword.
It does not compile.

If you consider that `var`, on the other hand, is NOT a keyword...

== 5. `var` is not a keyword in Java

Java 10  introduced `var`.
There are a lot of articles about how you can use `var` and why `var` is not syntactic sugar.
However, `var` is also not a keyword.

If it was a keyword, we could have a program, like

[source,java]
----
 1. public class VarNotKeyword {
 2.     final int var = 13;
 3.
 4.     void myMethod() {
 5.         int var = var().var;
 6.     }
 7.
 8.     VarNotKeyword var() {
 9.         return new VarNotKeyword();
10.     }
11.
12. }

----

which was a valid code before Java 10.
It still is because `var` is not a keyword, but it would be ruined if it was.
Luckily, it is not.

You cannot name a class to be `var`.
This means that even though `var` is not a keyword, we may still have some incompatibility.

== 6. Stream operations are mutating

It is also a Java secret, but at least this knowledge is not useless.
After all, who would like to read an article full of useless things?
As a matter of fact, there was a question on a Java interview, so it may even be essential to know.

When you chain the stream methods, they transform streams.
There is no operation happening until the final terminal operation is chained up and starts to execute.
The stream operations without the terminal operation only build up the operation chain.
They transform one stream into a new stream.

____
Not only!
____

Stream operations, like `map`, also modify the stream they are attached to.
The stream will remember that an operation was already attached to it and will throw an exception if you try to form a stream.
The following code demonstrates this:

[source,java]
----
1.         final Stream&lt;Object&gt; stream = Stream.of(&quot;a&quot;, 2, 3, new Object[2]);
2.         final var stringStream1 = stream.map(Object::toString);
3.         try {
4.             final var stream2 = stream.map(obj -&gt; &quot; &quot; + obj);
5.         } catch (IllegalStateException e) {
6.             System.out.println(e);
7.         }
8.         final var string = stringStream1.collect(Collectors.joining(&quot;\n&quot;));

----

The output of this is:

[source,text]
----
java.lang.IllegalStateException: stream has already been operated upon or closed

----

== 7. Streams do not always run

You know that the intermediary operations on a stream do not run if there is no terminal operation.
The terminal operation is the one that runs the streams invoking all the intermediary ones for the elements.
However, not all terminal operations run the whole chain.
It may lead to surprises in some cases.
To see that, let&apos;s use `peek()`.

`peek()` is a stream intermediary method that does not modify the stream.
The Javadoc of the method in the official JDK documentation says:

____
This method exists mainly to support debugging, where you want to see the elements as they flow past a certain point in a pipeline.
____

The same Javadoc then gives a sample that uses `System.out.println` to print values from a stream in different stages.
We will do the same

[source,java]
----
1.         final var w = Stream.of(1, 2, 3, 4, 5, &quot;apple&quot;, &quot;bird&quot;, 3.1415926)
2.                 .peek(System.out::println).toArray();
3.         System.out.println(w.length);

----

This sample goes through the elements of the stream.
It prints the elements of the stream and then the number of the elements as we have collected them to an `Object[]`:

[source,text]
----
1
2
3
4
5
apple
bird
3.1415926
8

----

This is nice and dandy.
What if we do not collect the elements?
In the example above, we are only interested in the number of elements; there is no reason to collect them into an array.

[source,java]
----
1.         final long z = Stream.of(1, 2, 3, 4, 5, &quot;apple&quot;, &quot;bird&quot;, 3.1415926)
2.                 .peek(System.out::println).count();
3.         System.out.println(z);

----

We expect to get the same output as before.
The reality, however, is that the output this time is:

[source,text]
----
8

----

Where did the elements go?
Why `peek` does not print the elements?

In this case, the terminal operation `count()` does not execute the stream pipeline.
Therefore, the `peek()` action is not invoked.
There is no magic or secret in it.
The JavaDoc of `count()` explains it.

____
An implementation may choose to not execute the stream pipeline ... if it is capable of computing the count directly from the stream source.
____

In some cases, like the one in the example above, the terminal operation `count()` does not need to iterate through the stream to know the number of elements.
So it does not.

Even the documentation of `peek()` has a link to this fact.
Nobody reads documentation.

== 8. `strictfp` is a modifier

Once upon a time, there was a keyword called `strictfp`.
It was introduced in Java 1.2 and required the floating point calculations to be performed differently.
Floating point calculations traditionally used the format IEEE 754 standard defined.
The early x86 processors with the x87 floating point coprocessor worked differently.
The coprocessor used a longer format, allowing more precision.
The `float` and `double` values were 64bit, but the generated code stored the intermediate values on more bits during a calculation.

Before Java 1.2, the compiler generated machine code modifying the result of every intermediate value to 64bit.
This required extra machine code operations and slowed the calculation down.
It was not only slower but more error-prone to overflow errors.
A calculation result could be okay with the 64-bit precision while some intermediate values overflowed.
Using more precision provided by the hardware could lead to the correct value.

`strictfp` was introduced to let the compiler generate a more effective floating-point code.
With 1.2 and later till Java 17, the compiler generates code using the extra precision unless the class or method is `strictfp`.

.just kidding
____
`strictfp` means that the floating calculation will result in the exact wrong result on all platforms.
____

Times change.
Pentium 4 in 2001 allows the compiler to avoid the extra code for strict floating point.
Java could generate the strict floating point effectively.

Java 17 came 20 years later, and Java changed again.
Java 17 later uses strict arithmetic even when `strictfp` is not specified.

You can still use it, and reflectively query its existence on a class, interface, or non-abstract method, but the Java compiler does not use it anymore.
Maybe, the Java compiler was the only one using `strictfp` even in the past.
At least, I have never met anyone who needed that and used it.

== 9. There are multiple `ArrayList` implementations in the JDK

If you have programmed Java for a long time, you know that you can easily create a list of elements calling `Array.asList()`.
If you look at the implementation of this static method, you can see that it is simply:

[source,java]
----
    @SafeVarargs
    @SuppressWarnings(&quot;varargs&quot;)
    public static &lt;T&gt; List&lt;T&gt; asList(T... a) {
        return new ArrayList&lt;&gt;(a);
    }
----

in the class `java.util.Arrays`.
Although the method&apos;s return type is the interface `List`, the documentation guarantees that the return type is `ArrayList`.
It says

____
Returns a fixed-size list backed by the specified array.
____

So it is an `ArrayList`.
Yes and no.
Let&apos;s try the following program:

[source,java]
----
1.         try {
2.             final ArrayList&lt;Integer&gt; x = (ArrayList) Arrays.asList(1, 2, 3, 4);
3.         } catch (ClassCastException cce) {
4.             System.out.println(cce);
5.         }

----

The output will be

[source,text]
----
java.lang.ClassCastException: class java.util.Arrays$ArrayList cannot be cast to class java.util.ArrayList (java.util.Arrays$ArrayList and java.util.ArrayList are in module java.base of loader &apos;bootstrap&apos;)

----

The returned list is an `ArrayList`, but it is a `java.util.Arrays$ArrayList` and not `java.util.ArrayList`.
These are two different classes and are not compatible.
One cannot be converted to the other; only the simple name is the same.

NOTE: Two classes are the same if their _canonical name_ is the same and were loaded by one class loader.
The simple name being the same is not enough.

Why did the implementors of `asList()` create a new `ArrayList` class?
Probably they wanted to create optimized code.
The list this method returns is backed up by an array just like the `java.util` one.
However, this array cannot be resized.
It is the same array that you provided as an argument.
It is not copied or cloned.
It remains in its place and is used by the list implementation.
You can see that in the following code sample:

[source,java]
----
1.         final Integer[] w = {1, 2, 3};
2.         final var wl = Arrays.asList(w);
3.         Assertions.assertEquals(1, wl.get(0));
4.         w[0] = 55;
5.         wl.set(1, 66);
6.         Assertions.assertEquals(55, wl.get(0));
7.         Assertions.assertEquals(66, w[1]);

----

When the code modifies the array, the list also gets modified.
When the list is modified, the array also gets modified.
That is because they are one and the same.

== 10. something != something

Recently a friend (Istvan Kovács) posted a puzzle on link:https://www.linkedin.com/feed/update/urn:li:activity:7022233914991640576/[Linked-in].
What should you write to the place of `???`

[source,java]
----
1.         final var variable = ???;
2.         if( variable == variable ){
3.             Assertions.fail(&quot;variable is == to variable&quot;);
4.         }

----

The question was: what should you write into the place of the `???` characters?
Unless you want to have a failing test, you need something which is not equal to itself.

It cannot be an object, because `==` compares the reference &quot;address&quot;, therefore an object is always `==` to itself.
It can only be a primitive value.

The solution comes from the link:https://ieeexplore.ieee.org/document/30711[IEEE 754] standard.
It has the sentence:

____
The exceptions are C predicates “ x == x ” and “ x != x ”, which are respectively 1 and 0 for every
infinite or finite number x but reverse if x is Not a Number ( NaN )
____

Although it talks about the C language, Java has inherited a lot from it.
Java implements the standard as we have already discussed related to the `strictfp` keyword.
That way the code sample is

[source,java]
----
1.         final var variable = Float.NaN;
2.         if( variable == variable ){
3.             Assertions.fail(&quot;variable is == to variable&quot;);
4.         }

----

or
[source,java]
----
1.         final var variable = Double.NaN;
2.         if( variable == variable ){
3.             Assertions.fail(&quot;variable is == to variable&quot;);
4.         }

----


== 11. Summary

We have visited ten Java features.
These are not important.
Writing about these was fun, and I hope reading them was also fun.
I tried to be precise, and I could not resist including some information that may also be useful despite the article title.

If you know any other more or less useless facts about Java, please write them down in the comments.</content><author><name></name></author><summary type="html">Article Management Technical Details Code https://github.com/javax0/javax0.github.io/tree/master/_projects/2023-01-23-ten-java Article source https://github.com/javax0/javax0.github.io/blob/master/_posts/2023-01-23-ten-java.adoc.jam</summary></entry><entry><title type="html">Hidden Classes in Java 15</title><link href="https://javax0.github.io/2023/01/05/hidden-classes.html" rel="alternate" type="text/html" title="Hidden Classes in Java 15" /><published>2023-01-05T00:00:00+01:00</published><updated>2023-01-05T00:00:00+01:00</updated><id>https://javax0.github.io/2023/01/05/hidden-classes</id><content type="html" xml:base="https://javax0.github.io/2023/01/05/hidden-classes.html">[%collapsible,title=Article Management Technical Details]
====
****
* Code link:https://github.com/javax0/javax0.github.io/tree/master/_projects/2023-01-05-hidden-classes[https://github.com/javax0/javax0.github.io/tree/master/_projects/2023-01-05-hidden-classes]
* Article source link:https://github.com/javax0/javax0.github.io/blob/master/_posts/2023-01-05-hidden-classes.adoc.jam[https://github.com/javax0/javax0.github.io/blob/master/_posts/2023-01-05-hidden-classes.adoc.jam]
****
====
== 1. Introduction

Java can have anonymous classes from the very start.
(Well, actually, they came in version 1.1 only.)
However, anonymous classes were not anonymous.
You did not need to name them, but under the hood, they were named by the Java compiler.
If you are familiar with the command `javap`, you can &quot;disassemble&quot; a JAR file and see the name of the compiler generated for the anonymous classes.

Java 15 introduced hidden classes, which do not have a name.
Almost, as you will see.
It is not part of the language but part of the JDK.
There is no language element to create hidden classes, but JDK methods and classes come to the rescue.

In this article, we will discuss

* what hidden classes are, and what is the reason to have them,

* how you can use hidden classes,

* how to load hidden classes using the JDK methods and, finally

* how to easily create and load hidden classes using link:https://github.com/sourcebuddy/sourcebuddy[SourceBuddy].

[NOTE]
====
I created SourceBuddy, an Apache v2.0 licensed open-source program.
While creating the code, I learned a few things about hidden classes I wanted to share with you.
You may also look at this article as a SourceBuddy promotion, which is ok if you do that.
Nevertheless, I hope to successfully add extra value to this article so that this is not simply a promo.
====


== 2. What are hidden classes?

There is an easy-to-read link:https://www.baeldung.com/java-hidden-classes[introductory article] about hidden classes on Baeldung.
If you are impatient and do not care about some intricate details, go there and read that article.
Baeldung articles are always short, focusing on the most important and correct.
They give a good starting point, which there would be no reason to repeat.

Hidden classes were proposed in the link:https://openjdk.org/jeps/371[JEP371], and it reads:

____
hidden ... classes that cannot be used directly by the bytecode of other classes
____

It is a bit short and may not be easy to understand.

A hidden class is loaded into the JVM.
When a class is in source code format or byte code, it cannot be &quot;hidden&quot;.
This term can refer only to loaded classes.
Calling them secretly loaded classes could be more appropriate.

A class gets hidden when it is loaded in a particular way so that it remains secret in front of other code parts.
Remaining hidden does not mean that other codes cannot use this class.
They can so long as long they &quot;know&quot; about the secret.
The big difference is that this class is not &quot;advertised&quot; because you cannot find it using the name.

When you load a class the hidden way creating a hidden class, you will have a reference to this class.
Using the reflective methods, you can instantiate the class many times, and then you can invoke methods, set, and get fields.
If the class implements an interface or extends a class, you can cast the instance reference to the interface and class and invoke the methods without reflection.

The class is hidden for two reasons:

* it does not have a name other classes could reference, and

* there is no reference from the class loader to the class.

When you call `getName()` or `getSimpleName()` on a variable referencing a hidden class, you will get some string.
These are names for messages for humans and are irrelevant for the other classes.
When a class refers to another class it needs the canonical name.
`getCanonicalName()` returns `null`.
The canonical name is the actual name of the class, which is non-existent in the case of hidden classes.

Since the class cannot be found through the class loader without the canonical name, there is no reason for the loader to keep a reference to the class.
Why would it keep a reference when it cannot give the class to anyone?
Keeping a reference would have only one side effect: preventing the GC from unloading the class so long as the class loader is alive.

Since there is no reference from the class loader, the GC can unload the class object as soon as it is out of use.


== 3. What is the use of hidden classes?

The link:https://openjdk.org/jeps/371[JEP371] describes the reason for hidden classes.
It says

____
Allow frameworks to define classes as non-discoverable implementation details of the framework so that they cannot be linked against other classes nor discovered through reflection.
____

Many frameworks use dynamically created classes.
They are proxy classes in most cases.
A proxy class implements an interface or extends another class, and when invoked, it calls an instance of the interface or the original class.
It usually does something extra as well, or else there would be no reason for the proxy class and instance.

An example is the Spring framework when your code requires injecting a request bean into a session bean.
(Or any other shorter lifecycle bean into a longer one.)
Several threads can serve different requests at the same time, all belonging to the same session.
All these threads will see the same session bean, but they magically will see their request beans.
The magic is a proxy object extending the request bean&apos;s class.
When you call a method on the request bean, you invoke the proxy instance.
It checks the thread and the request it serves and forwards the call to the appropriate request bean.

Another example is JPA lazy loading.
You can have an SQL table where each row references the previous one.
When you try to load the last record, it will automatically load the previous one, which indeed will load the one before.
It will load the whole table.
It happens unless you annotate the field as lazy.
It means that the actual data from the database has to be loaded only when it is needed.

When you load the record, you get a proxy object.
This proxy object knows which record it refers to and will load the record from the database only when a method is called.

The same mechanism is used for Aspect Oriented Programming and many other cases.

You can create a proxy class using only the JDK reflection API so long as the target class implements the interface you want to proxy.
You can use the link:https://bytebuddy.net/[ByteBuddy] library if there is no such interface.

[NOTE]
====
The link:https://github.com/cglib/cglib[cglib] library is widely used and well-known in many frameworks, but it has been deprecated recently.
====

When you create such classes, you do not need any name for these classes.
You get the reference to the class and the reference to the instance.
The framework injects the reference to the field it has to, and then the code uses them as any object.
It does not need to know the name of the class.
All it needs to know is that it is an instance of the target class or interface.
However, some codes may discover the name.
These classes have some names that reflection can discover.
Some &quot;clever&quot; junior may discover it and play some neat trick that you may have later issues maintaining.
Would it be better if there was no name at all?
Probably yes, it would be cleaner.
Hence: hidden classes.

[NOTE]
====
The proxy classes may also cause issues when you implement the `equals(Object other)` method.
The usual implementation of the link:https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)[equals] method compares the `other` object&apos;s class to the actual class.
It will eventually be `false` when the other object is a proxy instance.
What the `equals()` method should check is the assignability whenever there is a possibility that the `other` object is a proxy.
====

In addition to that, there is another reason to have hidden classes.
As soon as a class has a name, it is possible to discover it by the name.
The class loader has to keep the class alive to keep it discoverable.
The class loader has a reference to the loaded classes.
It means the garbage collector will not be able to collect the class, even when it is no longer in use.

If a class has no name, the class loader does not need to keep a reference to this class.
Class loaders do not keep references to hidden classes unless you explicitly instruct them to do so.
When all instances of a hidden class are collected, and there is no reference to the class, the garbage collector will recognize it as garbage.
The class loader will not keep the class in memory.

That way, the frameworks will not over-consume memory when a long-running code creates a lot of classes.
Better frameworks that collect unused classes do not need to create separate class loaders for these ephemeral classes.
There is no need to create a short-living, disposable class loader to make the class also disposable.

____
Support extending an access control nest with non-discoverable classes.
____

It is the second bullet point in the list of goals in the link:https://openjdk.org/jeps/371[JEP371].
JVM can load hidden classes in a way that they become a member of a nest.
What is a nest?

[NOTE]
====
If you know what a nesting host is and are impatient, jump to the following quote.
====

Well, it is a long story, but since it is Christmas time, I am on holiday, and the press will not print this article on the paper wasting tree, here it goes.
(I wrote this article for weeks. It is still not published, and already next year, January.)

Once upon a time, Java version 1.0 did not have inner classes.
Now, you better stop reading it here if you ask me what inner classes are.
Then Java version 1.1 introduced inner classes but did not change the JVM structure.
The JVM did not know anything about inner classes.
The Java compiler created regular (almost) top-level classes from the inner classes.
It invented some funny names, like `A$B` when there was a class `B` inside `A`.

NOTE: You can try to define an `A$B` top-level class in the same package where the class `A` containing the class `B` is.
`A$B` is a valid name.
You will see what the compiler does.

There was some hacking with the visibility though.
An inner class has the same visibility as the top-level class.
Anything private inside one compilation unit (file) is visible.
Visibility, however, is also enforced by the JVM.
But the JVM sees two top-level classes.
The compiler generated bridge methods in the classes wherever needed to overcome this issue.
They are package level for the JVM, and when called, they pass on the call to the private method.

Then came Java 11 something like 25 years later and link:https://openjdk.org/jeps/181[introduced the nest control].
Since Java 11, every class has a relation to another class or to itself, which is the nest host of the class.
Classes having the same nest host can see each other&apos;s, private members.
The JVM does not need the bridge methods anymore.

When you load a class hidden, you can specify it to become a member of the same nest (having the same nest host) as the class that created the lookup object.

NOTE: We have not yet discussed what a lookup object is and how to load a class hidden.
It will come.
As for now: a lookup object is something that can load a byte array as a hidden class into the JVM memory.
When a lookup object is created from inside a method of a class, the lookup object will belong to that class.
When a class is loaded as hidden using the lookup object, it is possible to pass an option to make the new hidden class belong to the nest in which the code created the lookup object.

Without the hidden class functionality, I do not know any other possibility to load a class that will belong to an already existing nest.
If you know of any possibility, write it in a comment.

The following bullet point reads:
____
Support aggressive unloading of non-discoverable classes, so that frameworks have the flexibility to define as many as they need.
____

It is an important point.
When you create a class, it remains in the memory so long as the classloader is alive.
Classloaders keep references to all the classes they loaded.
These references say that some code may ask the classloader to return the loaded class object by the name.
The application logic may long forget the class; nobody will ever need it.
Still, the garbage collector cannot collect it because there is a reference in the class loader.
A solution is to create a new class loader for every new non-hidden dynamically created class, but that is overkill.

Classloaders loading hidden classes do not keep a reference to the hidden class by default.
As with the nesting host, it is possible to provide an option to differ.

I do not see any reason.
There is no name, not discoverable, but keep an extra reference so the GC cannot throw it away.
If you see any reasonable use case, again: comment.

____
Deprecate the non-standard API sun.misc.Unsafe::defineAnonymousClass, with the intent to deprecate it for removal in a future release.
____

Very well.
Yes.
Absolutely.
Separate articles and many of them.

____
Do not change the Java programming language in any way.
____

Nice point. Sure.

With these, we discussed what hidden classes are.
You should have a firm understanding of their nature and why they are essential.
We also derailed a bit to nest hosting or host nesting, nesting hosting... whatever.
I hope it was of some value.

In the following, I will discuss how we create hidden classes using the JDK API and then using link:https://github.com/sourcebuddy/sourcebuddy[SourceBuddy].


== 4. Creating Hidden Classes

Articles and tutorials showing how to load hidden classes use precompiled Java classes.
These are usually part of the running application.
The tutorial calculates the path to the `.class` file and reads the byte code.

Technically this is correct but does not demonstrate the basic need for hidden class loading: load dynamically created classes hidden.
These classes are not dynamically created and could be loaded the usual way.

In this article, we will create a class from text, Java source on the fly -- during run-time -- and then load the resulting byte code as a hidden class.


[%collapsible,title=Code Sample Disclaimer]
====
****
The code samples are available on GitHub in the link:https://github.com/javax0/javax0.github.io/tree/master/_projects[project directory].
Each article has a project directory named `YYYY-MM-DD-article-title` where the project code files are.

For this article it is ``2023-01-05-hidden-classes``.

The samples are automatically copied from the project directory to the article using Jamal.
No manual copy, no outdated stale samples.
****
====

The sample project for this article contains only unit test files.
The class is `TestHiddenClassLoader`.
We have the source code for the hidden class stored in a field variable.

[source,java]
----
 1.     private static final String CODE1 = &quot;&quot;&quot;
 2.             package com.javax0.blog.hiddenclasses;
 3.
 4.             public class MySpecialClass implements TestHiddenClassLoader.Hello {
 5.
 6.                 @Override
 7.                 public void hello() {
 8.                     System.out.println(&quot;Hello, from the hidden class.&quot;);
 9.                 }
10.             }
11.             &quot;&quot;&quot;;

----

The interface is also inside the same class.

[source,java]
----
1.     interface Hello {
2.         void hello();
3.     }
4.

----

The following code is from one of the unit tests:

[source,java]
----
1.         final var byteCode = Compiler.java().from(CODE1).compile().get();
2.         final var lookup = MethodHandles.lookup();
3.         final var classLookup = lookup.defineHiddenClass(byteCode, true);
4.         final var helloClass = (Class&lt;Hello&gt;) classLookup.lookupClass();
5.
6.         final var hello = helloClass.getConstructor().newInstance();
7.         hello.hello();

----

We use the link:https://github.com/sourcebuddy/sourcebuddy[SourceBuddy] library in this code to compile the Java source to byte code.
The first line of the sample does that.
We use link:https://github.com/sourcebuddy/sourcebuddy[SourceBuddy] version 2.1.0.

We need a lookup object to load the compiled byte code as a hidden class.
This object is created on the second line.
The lookup object is used on the third and fourth lines to load the class hidden.
Line 3 defines the class loading it into the JVM.
The second argument, `true`, initializes the class.
That is when the `static{}` blocks execute.
The last line invokes the interface-defined method `hello()`.

Now the local variable `hello` is an instance of an object, a hidden class.
What are a hidden class&apos;s name, simple name, and canonical name?
Let&apos;s print it out.

[source,java]
----
1.         System.out.println(&quot;1. &quot; + hello.getClass());
2.         System.out.println(&quot;2. &quot; + hello.getClass().getClassLoader());
3.         System.out.println(&quot;3. &quot; + this.getClass().getClassLoader());
4.         System.out.println(&quot;4. &quot; + hello.getClass().getSimpleName());
5.         System.out.println(&quot;5. &quot; + hello.getClass().getName());
6.         System.out.println(&quot;6. &quot; + hello.getClass().getCanonicalName());
7.         System.out.println(&quot;7. &quot; + lookup.getClass());
8.         System.out.println(&quot;8. &quot; + lookup.getClass().getClassLoader());

----


[%collapsible,title=Output Disclaimer, sidebar]
====
[sidebar]
The output in the unit tests is redirected calling `System.setOut()`.
The output is collected to a file and then this file is included calling `include [verbatim]` Jamal macro into the article.
====

[source,text]
----
Hello, from the hidden class.
1. class com.javax0.blog.hiddenclasses.MySpecialClass/0x00000008011b0c00
2. jdk.internal.loader.ClassLoaders$AppClassLoader@5b37e0d2
3. jdk.internal.loader.ClassLoaders$AppClassLoader@5b37e0d2
4. MySpecialClass/0x00000008011b0c00
5. com.javax0.blog.hiddenclasses.MySpecialClass/0x00000008011b0c00
6. null
7. class java.lang.invoke.MethodHandles$Lookup
8. null

----

You can see the output from calling `hello()` and then the name as printed from the implicit `toString()` from the class object, the class loader that loaded the hidden class, the simple name, the name, and in the last line the canonical name.
This last one is interesting as it is `null`, showing no class name.
It is hidden.

The class, although hidden, has a reference to the class loader that loaded it.
It is needed when there is anything to resolve during the execution of the code.
The difference is that the class loader does not have a reference to the class.
One direction from the class to the loader exists, but the other direction from the loader to the class does not.

The class loader is the same as the one that loaded the class calling `MethodHandles.lookup()`.
You can see that since we printed out the class loader of the `this` object in the test.

Finally, we also print out the class of the lookup object and the class loader.
The latter is `null`, which means the bootstrap class loader loaded it. (For more information on class loaders, I can recommend reading the article link:https://www.baeldung.com/java-classloaders[class loaders] from the Baeldung blog.)

You should also note that the interface `hello` is package private.
It is still visible for the dynamically created code because it is in the same package and module.

[NOTE]
====
Starting with Java 9, there is a module system in Java.
Many developers I meet say they are not interested in JPMS; they do not need to use it.

The fact is that you DO use it, whether you want it or not.
It is the same as concurrent programming.
Java is concurrent; at least there are three threads in a JVM, so your code runs in a concurrent environment, whether you want it or not.
You may not have trouble understanding the details for a long time.
However, when you start digging deeper and creating code that uses some &quot;tricks&quot; or does something special, you almost certainly face some weird errors.
You must know and understand the underlying theory to understand the errors, handle them, mitigate the cause, and fix the bug.

Loading hidden classes dynamically created is precisely such a trick.
You should learn Java Modules.
====

When the hidden class is loaded, it is in the same package as the one where the interface is defined.
It is not enough, however, as we will see an example in the next section.
It is also a requirement that the same class loader loads the interface and the hidden class.
That way, the interface, and the hidden class are in the same module, in this case, the same unnamed module.
The different class loaders load classes into different modules; thus, when you load a class using a different class loader, it may not see the package fields, methods, interfaces, etc., even if they are in the same package.

It is not the only requirement that the lookup object is from the same module.
It is also a requirement that it is from the same package as the class to be loaded.
We must stop here to clarify things, to be painfully precise, because it is easy to confuse things at this point.

The lookup object is an instance of a class in the `java.lang.invoke` package.
The class loader loaded this class is `null` as shown in the output.
It means the bootstrap class loader.
The bootstrap class loader is implemented in C/C++ and not in Java.
No corresponding Java object represents this class loader; thus, there cannot be a reference to it.
It is solved by returning `null` from `getClassloader()`.
There is a module, package, and class that &quot;belongs&quot; to the lookup object.
The code&apos;s module, package, and class were called the `MethodHandles.lookup()` method.

You cannot create a hidden class from one package for another.
If you try that, like in the following sample code:

[source,java]
----
1.         try {
2.             final var byteCode = Compiler.java()
3.                     .from(&quot;package B; class A{}&quot;).compile().get();
4.             MethodHandles.lookup().defineHiddenClass(byteCode, true);
5.         } catch (Throwable t) {
6.             System.out.println(t);
7.         }

----

still from the test class `com.javax0.blog.hiddenclasses.TestHiddenClassLoader`.
The class to be loaded is NOT in the same package as the caller for `MethodHandles.lookup()`.
It will result in the printout:

[source,text]
----
java.lang.IllegalArgumentException: B.A not in same package as lookup class

----

== 5. Creating hidden classes the easy way

In the previous section, we created a new class dynamically and loaded the new class hidden.
The loading was done using lookup objects we acquired from the `MethodHandles` class.
In this section, we will see how we can do the same by calling the fluent API of link:https://github.com/sourcebuddy/sourcebuddy[SourceBuddy].

The code creating a class saying hello is the following:

[source,java]
----
1.         final var hello = Compiler.java()
2.                 .from(CODE1.replaceAll(&quot;\\.Hello&quot;, &quot;.PublicHello&quot;)).hidden()
3.                 .compile().load().newInstance(PublicHello.class);
4.         hello.hello();

----

In this code, we replaced the interface from `Hello` to `PublicHello`, which you may guess:

[source,java]
----
1.     public interface PublicHello {
2.         void hello();
3.     }

----

It is essentially the same as the previous interface but is `public`.
The process is much more straightforward than before.
We specify the source code; we declare that it is a hidden class calling `hidden()`, and we compile, load, and ask for an instance cast to `PublicHello`.

If we want to use the package-private interface, like (not replacing `Hello` to `PublicHello`):

[source,java]
----
1.         Assertions.assertThrows(IllegalAccessError.class, () -&gt;
2.                 Compiler.java().from(CODE1).hidden().compile().load().newInstance(PublicHello.class));

----

we will get an error.

[source,text]
----
java.lang.IllegalAccessError: class com.javax0.blog.hiddenclasses.MySpecialClass/0x00000008011b1c00 cannot access its superinterface com.javax0.blog.hiddenclasses.TestHiddenClassLoader$Hello (com.javax0.blog.hiddenclasses.MySpecialClass/0x00000008011b1c00 is in unnamed module of loader com.javax0.sourcebuddy.ByteClassLoader @4e5ed836; com.javax0.blog.hiddenclasses.TestHiddenClassLoader$Hello is in unnamed module of loader &apos;app&apos;)

----

The reason is explained clearly in the error message.
The interface and the class implementing it are in two different modules.
Both are unnamed modules, but they are not the same.
In Java, starting with Java 9, there are modules, and when the application does not use modules, it essentially creates pseudo modules putting the classes there.
The JDK classes are still in modules, like `java.base`.

The hidden class creation, as created above, uses a separate class loader to load the dynamically written Java class.
The separate class loader loads classes to its module.
Code in different modules cannot see classes from other modules unless they are public.

Although link:https://github.com/sourcebuddy/sourcebuddy[SourceBuddy] does a little trick to load a class hidden, it cannot overcome this restriction.

Loading a hidden class needs a lookup object.
The application usually provides this object.
The calls above do not specify any lookup object, but link:https://github.com/sourcebuddy/sourcebuddy[SourceBuddy] still needs one.
To have one, it creates one.
The lookup object remembers the class called `MethodHandles.lookup()` to create one.
When loading a class hidden, it is required that the lookup object &quot;belongs&quot; to the class&apos;s package.
The lookup object was created, calling for it from a class, which is *in* that package.
The lookup object will &quot;belong&quot; to that class and hence to the class&apos;s package.

To have a lookup object that comes from a class from a specific package we need a class in that package that can give us one.
If there is none in the code, we must create one dynamically.
link:https://github.com/sourcebuddy/sourcebuddy[SourceBuddy] does that exactly.
It creates the Java source code for the class, compiles it and loads it, instantiates it, and calls the  `Supplier&lt;MethodHandles.Lookup&gt;` defined `get()` method the class implements.

It is a kind of trick that seems to violate the access control built-in to Java.
We seem to get a new hidden class in a package that was not prepared for it.
A package is protected from external access in Java (trivial).
Only public and protected members and classes can be used from outside the package.
The package can be accessed using reflection from the outside, but only in the same module, or the module has to be opened explicitly.
Similarly, an object loaded using a lookup object should be in the same package and access the package&apos;s internal members and whatnot if a class in the package provided that lookup.

As we can see from the error message, it only seems to be the package.
In reality, the new hidden class is in a package with the same name but in a different module.

If you want to have a hidden class in the same package and not only a package with the same name, you need a lookup object from that package.

In our example, it is simple.
Our `Hello` interface is in the same package as the test code so that we can create the lookup object ourselves:

[source,java]
----
1.         final var hi = Compiler.java().from(CODE1).hidden(MethodHandles.lookup()).compile()
2.                 .load().newInstance(Hello.class);
3.         hi.hello();

----

Access to a lookup object may be a bit more complex in real-life examples.
When the code calling link:https://github.com/sourcebuddy/sourcebuddy[SourceBuddy] is in a different package than the code generated, the lookup object creation cannot be in the link:https://github.com/sourcebuddy/sourcebuddy[SourceBuddy] calling code.

In the following example, we will see how that will be done.

We have a class `OuterClass` in the package `com.javax0.blog.hiddenclasses.otherpackage`.

[source,java]
----
 1. package com.javax0.blog.hiddenclasses.otherpackage;
 2.
 3. import java.lang.invoke.MethodHandles;
 4.
 5. public class OuterClass {
 6.
14.     public static MethodHandles.Lookup lookup() {
15.         return MethodHandles.lookup();
16.     }
17. }

----


NOTE: Some lines are skipped from the class. We will use those later.

This class has a method, `lookup()`.
It creates a lookup object and returns it.
We will have a proper lookup object if we call this method from our code.
Note that this class is in a different package and not the same as our test code.
Our test code is in `com.javax0.blog.hiddenclasses`, and `OuterClass` is a package deeper.
Essentially in a different package.

We also have another class for the demonstration.

[source,java]
----
1. package com.javax0.blog.hiddenclasses.otherpackage;
2.
3. class MyPackagePrivateClass {
4.
5.     void sayHello(){
6.         System.out.println(&quot;Hello from package private.&quot;);
7.     }
8.
9. }

----

It is a package-private class with a package-private method in it.
If we dynamically create a hidden class, as in the following example:

[source,java]
----
 1.         final var hidden = Compiler.java().from(&quot;&quot;&quot;
 2.                 package com.javax0.blog.hiddenclasses.otherpackage;
 3.
 4.                 public class AnyName_ItWillBeDropped_Anyway {
 5.                     public void hi(){
 6.                         new MyPackagePrivateClass().sayHello();
 7.                     }
 8.                 }&quot;&quot;&quot;).hidden(OuterClass.lookup()).compile().load().newInstance();
 9.         final var hi = hidden.getClass().getDeclaredMethod(&quot;hi&quot;);
10.         hi.invoke(hidden);

----

It will work.

There is one topic that we have not touched on.
It is how to create a nestmate.

When you have a binary class file, you can load it as a nestmate to a class that provides a lookup object.
The JVM does not care how that class was created.
When we compile Java sources, we only have one possibility.
The class has to be an inner class.

When you use link:https://github.com/sourcebuddy/sourcebuddy[SourceBuddy], you have to provide your source code as an inner class to the one you want the hidden to be nest mate with.
The source code and the class was already provided when you compiled your code.
It is not possible to insert into THAT source code any new inner class.
We have to fool the compiler.

We provide a class having the same name as the one we want to insert our inner class later.
When the compilation is done, we have the outer class and the inner class as well.
We tell the class loading to forget the outer and only to load the inner one, hidden.

It is what we will do.
This time we display here the whole outer class that we use for demonstration including the skipped lines.

[source,java]
----
 1. package com.javax0.blog.hiddenclasses.otherpackage;
 2.
 3. import java.lang.invoke.MethodHandles;
 4.
 5. public class OuterClass {
 6.
 7.     // skip lines
 8.     private int z = 55;
 9.
10.     public int getZ() {
11.         return z;
12.     }
13.     // end skip
14.     public static MethodHandles.Lookup lookup() {
15.         return MethodHandles.lookup();
16.     }
17. }

----

As you will see, it has a private field and a getter to test the changed value effectively.
It also has the before-mentioned `lookup()` method.
The code dynamically creating an inner class is the following:

[source,java]
----
 1.         final var inner = Compiler.java().from(&quot;&quot;&quot;
 2.                         package com.javax0.blog.hiddenclasses.otherpackage;
 3.
 4.                         public class OuterClass
 5.                                                 {
 6.                             private int z;
 7.
 8.                             public static class StaticInner {
 9.                                public OuterClass a(){
10.                                  final var outer = new OuterClass();
11.                                  outer.z++;
12.                                  return outer;
13.                                }
14.                             }
15.
16.                         }&quot;&quot;&quot;).nest(MethodHandles.Lookup.ClassOption.NESTMATE).compile().load()
17.                 .newInstance(&quot;StaticInner&quot;);
18.         final var m = inner.getClass().getDeclaredMethod(&quot;a&quot;);
19.         final var outer = (OuterClass)m.invoke(inner);
20.         Assertions.assertEquals(56, outer.getZ());

----

There is an `OuterClass` in the source, but it is only to help the compilation and to tell link:https://github.com/sourcebuddy/sourcebuddy[SourceBuddy] the name of the nesting host.
When we call the method `nest()` with the option `NESTMATE`, it knows that the class `OuterClass` is the nesting host.
It also marks the class not to be loaded by the class loader ever.
The inner class compiles to a different byte code, and when it is loaded, it becomes a nestmate of `OuterClass`.

If you pay attention to the intricate details of Java access control discussed in this article, you will notice that we do not provide a lookup object.
And the example above still works.
How is it possible?
There is no magic.
When you call `nest()`, link:https://github.com/sourcebuddy/sourcebuddy[SourceBuddy] looks for the already loaded version of `OuterClass` and fetches the lookup object using reflection.
To do that the outer class has to have a static field or method of type `MethodHandles.Lookup`.
`OuterClass` has a method, so link:https://github.com/sourcebuddy/sourcebuddy[SourceBuddy] calls this method to get the lookup object.

The example above creates a static inner class.
You can create the same way a non-static inner class as well.

[NOTE]
====
The difference between static and non-static inner classes in Java is that non-static inner class instances have a reference to an outer class instance.
Static inner classes do not.
It is where the name comes from.
Static inner class instances belong to the class.
Non-static belongs to an instance of the outer class.

To get the reference to the outer class instance, the inner class&apos;s constructor is modified.
When you specify a constructor for an inner class, the compiled adds an extra parameter in front of the other parameters specified in the Java source code.
This extra first parameter is the reference to the outer class instance.
This reference is stored in a field not available at the source level but used by the code to access the fields and methods of the outer instance.
====

The creation of a non-static inner class looks very much the same as the creation of a static inner class:

[source,java]
----
 1.         final var outer = new OuterClass();
 2.         final var inner = Compiler.java().from(&quot;&quot;&quot;
 3.                         package com.javax0.blog.hiddenclasses.otherpackage;
 4.
 5.                         public class OuterClass {
 6.                             private int z;
 7.
 8.                             public class Inner {
 9.                                public void a(){
10.                                  z++;
11.                                }
12.                             }
13.
14.                         }&quot;&quot;&quot;).nest(MethodHandles.Lookup.ClassOption.NESTMATE).compile().load()
15.                 .newInstance(&quot;Inner&quot;, classes(OuterClass.class), args(outer));
16.         final var m = inner.getClass().getDeclaredMethod(&quot;a&quot;);
17.         m.invoke(inner);
18.         Assertions.assertEquals(56, outer.getZ());

----

We need an instance of the outer class to instantiate the inner class.
It is the variable `outer`.
We must pass this variable to the constructor through the `newInstance()` API of link:https://github.com/sourcebuddy/sourcebuddy[SourceBuddy].
This method call has a version that accepts a `Class[]` and an `Object[]` array specifying the constructor argument types and values.
In the case of an inner class, it is the outer class and an instance.


== 6. Summary

This article discussed some details of the hidden classes introduced in Java 15.
We went a little deeper than the usual introductory articles.
Now you understand how hidden classes work and how to use them in your projects.


[%collapsible,title=&quot;How to Comment&quot;, sidebar]
====
****
Use the Disqus commenting possibility to comment.
If you find any incorrectness in the article, you are welcome to mention it.
You can also access the source code of the article on github at

link:https://github.com/javax0/javax0.github.io/blob/master/_posts/2023-01-05-hidden-classes.adoc.jam[`https://github.com/javax0/javax0.github.io/blob/master/_posts/2023-01-05-hidden-classes.adoc.jam`]

You are welcome to create a link:https://github.com/javax0/javax0.github.io/issues/new[ticket], create a  link:https://github.com/javax0/javax0.github.io/fork[fork], suggest modification via pull requests.
Note that this repository also contains the demonstration sample source code.

For other aspects of commenting read the link:https://javax0.github.io/about/[ABOUT] page of this blog.
****
====</content><author><name></name></author><summary type="html">Article Management Technical Details Code https://github.com/javax0/javax0.github.io/tree/master/_projects/2023-01-05-hidden-classes Article source https://github.com/javax0/javax0.github.io/blob/master/_posts/2023-01-05-hidden-classes.adoc.jam 1. Introduction</summary></entry><entry><title type="html">Technology behind this post</title><link href="https://javax0.github.io/2022/12/07/blog-posting.html" rel="alternate" type="text/html" title="Technology behind this post" /><published>2022-12-07T00:00:00+01:00</published><updated>2022-12-07T00:00:00+01:00</updated><id>https://javax0.github.io/2022/12/07/blog-posting</id><content type="html" xml:base="https://javax0.github.io/2022/12/07/blog-posting.html">== 1. Introduction

`/Users/verhasp/github/javax0.github.io/_posts`

This blog is the continuation of the blog post at the WordPress-hosted javax0 blog that was at https://javax0.wordpress.com[javax0.wordpress.com].
The technology, the hosting, and all were okay by that time, but times changed.
This blog post describes why I changed the blog technology and what technology I use here to write these blog posts.

== 2. Problems with WordPress

First, I have to state that I am not saying or implying that WordPress would not be an excellent platform.
It is a well-established and a kind of one of its kind, de-facto number-one blogging forum.
The problems are specific to my particular needs for this blog.
These needs may not be specific to my person, but a bit more general: technical blogging.

It is like Opel, Toyota, VW, or any other average, workhorse car type.
Opel is a good car; it runs, is reliable, and is reasonably priced.
However, if I am a farmer and need to plow my fields, I will probably choose a tractor instead.
In this analogy, the farmer is a __technical__ blogger.
Emphasis is on __technical__.
For anybody else: WordPress is an excellent choice.

Let&apos;s have a look at the issues that I had.

=== 2.1. Markup

When I write anything, I like to edit some markup.
I can use Word or LibreOffice.
I was using DEC Write in the early 1990-is if you are old enough to know what that is but not too old to forget things and still remember.
Even at that time, I preferred markups, which at that time were TeX and LaTeX.

[NOTE]
====
I even wrote a hyphenation preprocessor for Tex for the Hungarian language, and it became a standard part of some Linux distributions.
Since they installed Linux on  Mars Rovers, sometimes I entertain myself with the idea that some of my code got as far as planet Mars.
Please let me have this fantasy, and do not correct me if I am wrong.
====

We could use other markups, like APT, Markdown, Asciidoc, and many others over the years.
These days two of those are used mainly, Markdown and Asciidoc.
WordPress hosted site supported or still supports Markdown, but I started to prefer Asciidoc for these blogs.
The only problem was that I could not.

=== 2.2. Code Samples

When I write some technical blogs, I include code samples.
I develop the code first, and then I write the article.
That is the principle.

However, the practice is that after I started to write the article, I realized that the code was not perfect.
So I changed the code and copied the relevant part to the article sample displays.
Unless I forget to update some of those after a few iterations.

It was also the case when I wrote my first book, and I have sworn that it will never happen again.

=== 2.3. Version Control

Editing on WordPress works, and you can look at the different versions.
But it is not comparable with the possibilities provided by a Git repository.

== 3. The New Blog Technology

=== 3.1. Github Pages and Jekyll

The new technology stack for blogging is based on GitHub pages.
It is not unique, and it has support for Jekyll, which is a static blogging engine.
Setting up a Jekyll-based blog is pretty straightforward.
I already had the organization name `javax0` on GitHub.
It only seemed logical to use this as `javax0.github.io` for blogging.
Later I may use the `javax0.com` domain that I also keep.

Installing Jekyll on my MacBook was a bit tricky.
First, I had to install the newest Ruby.
An old version of Ruby comes preinstalled on every macOS.
This old version is not suitable for running Jekyll.
I used brew, but it failed, complaining that I was not on the sudoer list.
It took a while until I realized that, for some reason, two `sudo` programs were installed on my machine.
The brew installer used a different one than what I reached from the command line.
I had to add myself to the other sudoer&apos;s list as well.
The last trick was to tweak the `PATH` so Jekyll would use the newest Ruby version.
After that, there was still some problem when I configured Jekyll to run locally and on GitHub.
It was executing some commands following some StackOverflow page suggestions.

Sometimes I had no idea what I was doing.
I can only hope that I did not install malware during the process.
You, AsciiDoc, Jekyll, and other tool developers have all my trust.

I integrated JRuby into Jamal, but I do not program in Ruby.

=== 3.2. Jekyll Asciidoc Plugin

In addition to Jekyll, I also installed the Asciidoc plugin for Jekyll.
Since both Asciidoctor and Jekyll are written in Ruby, it was nothing more than issuing a few commands.

=== 3.3. Jamal

The extra part, which is not a standard Asciidoc-boosted Jekyll installation, is my use of Jamal.
The main reason to use Jamal is to include the code samples in the blog posts, but it does much more than that.

I wrote above that I struggled with maintaining the code samples when writing my books.
I created the pyama tool in Python for the second book I wrote.
It copies the code snippets into the text file that I edited.
Later I developed the snippet module for Jamal, which revolves around this concept.
Keep the source in the code files, have only a reference in the document, and copy it in the CI/CD process.
I hesitated to use Jamal and the snipped module myself for a long time.
It is easier to edit a file showing some code when the code is there a few lines above.
Pyama was copying the code into the edited file.
Jamal does not do that.
Jamal can also do that, but I do not recommend using that feature.
A source file is a source file.

When I created the Asciidoctor Jamal plugin that can plug Jamal functionality into Asciidoctor and delivers Jamal WYSIWYG editing in IntelliJ, the situation changed drastically.
There was no reason more to use something like pyama.

NOTE: Pyama is still available in my GitHub, but there are much better tools for the purpose.

Using Jamal, I can include code snippets and delete or keep some lines by selecting regular expressions or line numbers.
I can number the lines, and I can still use all the Asciidoctor formatting features at the same time.

=== 3.4. Installing Jamal

Installing Jamal to use in IntelliJ is very simple.
All it takes to download a ZIP file and extract the content into the projects `.asciidoctor/lib` directory.
You should open IntelliJ settings and associate the `.jam` extension with the Asciidoctor plugin (in addition to the other default extensions already there).
Restart IntelliJ, and you can start editing your first Jamal-enabled Asciidoc file.

As you edit the file on the left pane, you see the formatted text on the right pane.
It is how the plugin works, but you can also use Jamal macros now.

image::https://javax0.github.io/assets/images/image-2022-12-09-16-47-43-394.png[width=500]

=== 3.5. Blogging Macros

There are not too many specific macros that differ from other documentation macros.
Most of the macros I use in Jamal are snippet macros and built-in core ones.
Some macros help scan the snippets following the directory naming conventions of the site.
There are some macros to reference one article from another easily.

=== 3.6. Deploying the Site

Deployment of the site is simply a git push.
Almost.
The site has to be built before.
There is a simple build script:


[source,bash]
----
#!/bin/sh
./build
git add --all docs
git commit -m &quot;deploy&quot;
git push
open https://javax0.github.io
----

This script builds the site, adds all the new and modified generated files, and then pushes it to the git server.
It also opens the web page, so I can immediately see the blog&apos;s opening page after it is deployed.

I tried to let GitHub pages do the building of the Jekyll site.
After all, it supports Jekyll.
The problem is that GitHub does not support the Jekyll Asciidoc plugin.
It is a bit strange: Asciidoc is natively supported by GitHub, and any readme or other files can be Asciidoc.
Still, GitHub Sites cannot be, except if they are built and deployed elsewhere.

.update at 2023-01-25
== 4. Building the site

Building the site was first was a simple `Makefile` starting Jamal via `jbang` to convert all the `.adoc.jam` files to `.adoc` from the directory `_posts`.
This, however, resulted almost 400 files in the directory.
During the course of the last ten years I wrote 180 articles.
All their `.adoc.jam` and the generated `.adoc` files got into one flat directory.

To mitigate this situation I decided to group the articles into subdirectories by years.
It means eleven subdirectories now and 15 to 20 more in my lifetime.
It is manageable.
The problem was I did not know how to write a general `make` rule that says `.adoc.jam` files in the subdirectories should be compiled to `.adoc` files in the `_posts` directory.

I used Jamal to the rescue.
What else?
I created a `Makefile.jam` with the following content:

[source,bash]
----
{@sep [% %] }[%@import tab.jim%]\
all:  [%!@for [evalist] $file in `//` [%@listDir (pattern=&quot;\\.adoc\\.jam$&quot;) _posts%]`//` =[%@comment%]\
 _posts/[%@file (format=$naked1)$file%]%]\

[%!!#for $dir in ([%@listDir (maxDepth=1 pattern=&quot;/\\d{4}$&quot;)_posts%])=[%@comment%]\
  [%@ident
    [%@for [evalist] $file in `//` [%@listDir (maxDepth=1 pattern=&quot;\\.adoc\\.jam$&quot;) $dir%]`//` =[%@comment%]\
    [%#define YYYY=[%#replace (regex)|$dir|.*/_posts/||%]%]\
    [%#define SOURCE=_posts/[%YYYY%]/[%#file (format=$simpleName)$file%]%]\
    [%#define TARGET=_posts/[%@file (format=$naked1)$file%]%]
[%TARGET%] : [%SOURCE%]
[%tab%]jbang jamal@verhas -open=&apos;{%&apos; -close=&apos;%}&apos; [%SOURCE%] [%TARGET%]
    %]%]%]

----

I do not expect you to understand this structure.
It is fairly complex,but it shows the power of Jamal in some way.
You should not feel intimidated.
If you decide to use Jamal only for 10% of what it can do, it is fine.
It is a tool to provide value and not something you need to master.

This Jamal code lists all the files and generates `Makefile` rules for each `.adoc.jam` article.
I struggled a bit with spaces and tabs.
IntelliJ does not preserve the tabs, except when it is a `Makefile`.
However, `Makefile.jam` is NOT `Makefile`.
As a workaround I created a `tab.jim` file:

[source,bash]
----
{@define tab=	} &lt;- this is a tab character
A simple tab character.

This file is not to be edited other than vi.
Other editors may replace the TAB character with spaces.
Files can import this file and use {tab} in Makefiles.
To exit vi press the escape key and then capital Z twice.
Without saving: escsape and then :q!

----

The comment in the file says it all, I wil not repeat here.

I may later move the `YYYY` yearly subdirectories from `_posts` to make the `_posts` directory something that I never need to open in the editor.
Look at the GitHub repo to see if I did that.

== 5. What will be Missing

WordPress very neatly showed the statistics of the site.
I do not know if I can get such statistics here.
Probably not.

On the other hand, most of the readers for my articles came from the republishing sites DZone and Java Code Geeks.
I will keep them.
(Note to myself: I have to inform them about the blog&apos;s new location officially.)
They automatically fetch the blog posts.
So I do not need to do anything.
They select from the published articles.
They only repost the good ones.

If you know any other aggregator I should contact, give me some advice. I am open.

== 6. Summary

I hope blogging using this toolset will be much more fun than the old technology.
At least, I am less likely to end up in some articles with `&amp;amp;lt;` and `&amp;amp;gt;` infested source codes.
(I had to apply a unique trick to get them here.)

This type of blogging using Asciidoc, Jekyll, and Jamal is more a Doc as a Code that I advocate heavily.
We will see how it will work.</content><author><name></name></author><summary type="html">1. Introduction</summary></entry><entry><title type="html">Docs as Code is not enough</title><link href="https://javax0.github.io/2022/05/24/docs-as-code.html" rel="alternate" type="text/html" title="Docs as Code is not enough" /><published>2022-05-24T00:00:00+02:00</published><updated>2022-05-24T00:00:00+02:00</updated><id>https://javax0.github.io/2022/05/24/docs-as-code</id><content type="html" xml:base="https://javax0.github.io/2022/05/24/docs-as-code.html">&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;1-docs-as-code&quot;&gt;1. Docs as Code&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;1-1-it-is-the-first-step-to-the-right-direction&quot;&gt;1.1. it is the first step to the right direction&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The approach to treating your documentation the same way as program code is a step in the right direction, but it is far from state-of-the-art. The practice is detailed on many websites that advocate the use of docs-as-code (DAC). For example the &lt;a href=&quot;https://www.writethedocs.org/guide/docs-as-code/&quot;&gt;Write the Docs&lt;/a&gt; community has a great article on docs-as-code. The article lists&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Issue Trackers&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Version Control (Git)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Plain Text Markup (Markdown, reStructuredText, Asciidoc)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Code Reviews&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Automated Tests&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;as required tools to this approach. Another example is &lt;a href=&quot;https://docs-as-co.de/&quot;&gt;docs-as-code&lt;/a&gt;, which is a toolset for documentation maintenance. They write&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;With docs-as-code, you treat your documentation the same way as your code.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You use…&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;your IDE to write it
your version control system to store and version it
your test-runner to test it
your build system to build and deploy it&quot;&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This is very much the same as the approach of &lt;a href=&quot;https://www.writethedocs.org/guide/docs-as-code/&quot;&gt;Write the Docs&lt;/a&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/verhas/jamal/master/jamal-snippet/articleimages/docs-as-code-3.svg&quot; alt=&quot;docs as code 3&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You have to have your documents in a format supported by the DAC tools. Use version control, document review, automated build, issue tracker, and automated tests. It is very much the same approach we use in code development.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Essentially it is a copy of the professional software development process&apos; coding part. Documentation, however, is not coding. While it is a good idea to reuse some parts of the coding methodology technics, there is more to it.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/verhas/jamal/master/jamal-snippet/articleimages/docs-as-code-4.svg&quot; alt=&quot;docs as code 4&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;2-what-docs-as-code-ignores&quot;&gt;2. What docs-as-code Ignores&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Coding is a transformation process converting documentation, namely the requirement documentation, into code. The requirement documentation may not be documentation in the classical sense. It may be some note, a list of wishes on a jot of paper. Still, the essence is to convert some human affine into machine affine. Some techniques try to support this process, but most of these techniques die when in production. For example, creating the documentation as UML and making it so precise that the code generation is automatic afterward is not feasible. You could do it in principle, but the cost of the effort is too high. It is cheaper to create the code than documentation that defines the functionality with mathematical precision.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Documenting an application is precisely the opposite direction.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/verhas/jamal/master/jamal-snippet/articleimages/docs-as-code-5.svg&quot; alt=&quot;docs as code 5&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Something that failed in one direction does not necessarily fail when we try to go the other direction. You may not be able to jump from the river to the bridge, but the other way is very much possible.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;When creating the program documentation, our source is precisely describing the functionality we want to document. After all, the code is the most precise documentation of the application functionality. We already have the precision, which was not feasible to have for the other way around.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The docs-as-code approach, as described by most articles, ignores it. However, it can be amended, and it should be. We can look at it as the next step in the docs-as-code evolution.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;2-1-the-next-step&quot;&gt;2.1. The next step&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We can categorize documentation into two categories.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Explanatory, and&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Reference&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Sometimes a document belongs to one of the categories, but documents are a mix of the two most of the time. It may even happen that you cannot even tell if a sentence in a document belongs to one category or the other.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Creating an explanatory style text cannot be automated. It needs human effort to create sentences that are clear and easily understandable. The importance is demonstrated by the lack of them in this article, as you may have noticed.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;However, creating the reference text is more or less a mechanical task. The documentarian (a term from write-the-docs) copies the key&amp;#8217;s name to explain how to configure the system and writes a sentence around it. Copies some sample code from the unit tests into a code segment into the Asciidoc documentation and adds explanation. The reference is taken from the code verbatim in these examples, and the explanatory part is added.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/verhas/jamal/master/jamal-snippet/articleimages/docs-as-code-1.svg&quot; alt=&quot;docs as code 1&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You can automate the copy of the reference information. Most of the time, it is not automated.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The catch is that automation, just as in the case of tests, is more expensive than doing manual work once. It pays back when the actual operation (copy and paste) happens many times.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;And it usually does. To be more precise, it is supposed to happen. However, the documentation maintenance misses the task in practice, and the document becomes stale. It is where the docs-as-code automated test may help. In principle, it is possible to create a test checking the documentation and find discrepancies between the names in the code and the documentation. It can be heuristic, or it can be exact. To do it the exact way, the documentation and/or the code needs meta-information helping the test to perform the consistency check.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Such a test can signal that the documentation may be outdated and need change. For example, it may give a warning, like&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&quot;The name of the field XYZ is not the same as in the documentation ZZZ. Change ZZZ in the documentation to XYZ&quot;.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It is a foolish and outrageous error message. I immediately know that the program architecture is messed up when I see such an error message. If the test can tell me what to do with such precision, it could fix the problem with the same effort.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It is much better if we let the automated build copy the actual name instead of checking that the human did it correctly. To do that, the documentarian should put the meta-information into the documentation instead of the copied value. The meta-information is read by the automated build tool, and using that; it copies the actual value or values.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If the value changes, the build process will automatically change it.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Another advantage is the lesser possibility for error. If the documentarian makes a mistake copying the field&amp;#8217;s name, the text will not complain. If he writes XXY instead of XYZ, the documentation will contain the wrong name unless some human review process discovers and fixes the bug. If the documentarian inserts the meta information and makes a mistake, the build process will likely fail. If instead of XYZ, I have to write &lt;code&gt;{java:field com.javax0.jamal.api#XYZ}&lt;/code&gt; any simple typo will be detected. If there is a field  &lt;code&gt;com.javax0.jamal.api#XYZ&lt;/code&gt; it is unlikely to have also &lt;code&gt;com.javax0.jamal.api#XXY&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/verhas/jamal/master/jamal-snippet/articleimages/docs-as-code-2.svg&quot; alt=&quot;docs as code 2&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;With this approach, the docs-as-code workflow is extended. The documentation&amp;#8217;s &quot; source code &quot; starts behaving as a source code. The automated build is no longer simply formatting and executing language checks. The goal is to automate everything that you can automate. It may not be cheaper than doing the work manually, but certainly less error-prone.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;3-tools&quot;&gt;3. Tools&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;All the above theory is pleasant and attractive but worth nothing unless there are tools to implement them. My motivation writing this article is partly to advocate the use of the open-source tool &lt;a href=&quot;https://github.com/verhas/jamal&quot;&gt;Jamal&lt;/a&gt;. Although Jamal is a general-purpose macro language and can be used in many areas, its primary purpose is document maintenance support. It is a simple to write, non-intrusive macro language. Using it, you can insert meta-information into the documentation to be processed by the automated build. You can use it with any plain text document format, like Asciidoc, markdown, apt, etc. The latest releases also support the DOCX format to use it even with Microsoft Word.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The set of the macros is quite extensive, and it is easy to add your own. The documentation support module can gather information from the application&amp;#8217;s source code as snippets. Snippets can then be transformed, extracted, and inserted into the documentation. Information from the code can be extracted using text tools using the source code text. However, in the case of Java applications, the document transformation may also collect information using reflection. It can be done because Jamal itself is a Java application.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It can be started on the command line as a maven plugin and a maven extension. It is also embedded as a doclet and a taglet to allow Jamal macros in the JavaDoc documentation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You can use macros to check the consistency of the documentation and the code. You can mark some part of the code as a snippet, and the documentation related to the specific region may contain the hash code of the piece. When the part changes in the source code, the macro evaluation will automatically signal an error.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The application of Jamal is independent of build automation. It can be antora, jBake, or simply a maven project with different plugins. The application of Jamal is also independent of the documentation format. It can be Asciidoc, markdown, apt, etc., as long as the documentation format is text. Using the Word extension included in the command line version, it can even be Microsoft DOCX Word format.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;4-conclusion&quot;&gt;4. Conclusion&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Treating documentation as source code is a good idea and a good start. It can, and should, however, be extended to include more features. When you treat your documentation as a source code, you should not stop simply using built automation, automated testing, review processes, and versioning. You should also apply techniques like Don&amp;#8217;t Repeat Yourself (DRY). Extra tools exist and seamlessly integrate with the already existing build and formatting tools to do that.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;comments-imported-from-wordpress&quot;&gt;Comments imported from Wordpress&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;Docs as Code is not enough - Java Code Geeks - R4 News&lt;/strong&gt; 2022-04-04 05:02:00&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;[&amp;#8230;] Published on Java Code Geeks with permission by Peter Verhas, partner at our JCG program. See the original article here: Docs as Code is not enough [&amp;#8230;]&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content><author><name></name></author><summary type="html">1. Docs as Code</summary></entry><entry><title type="html">Lambda and final variables</title><link href="https://javax0.github.io/2021/12/08/lambda-and-final-variables.html" rel="alternate" type="text/html" title="Lambda and final variables" /><published>2021-12-08T00:00:00+01:00</published><updated>2021-12-08T00:00:00+01:00</updated><id>https://javax0.github.io/2021/12/08/lambda-and-final-variables</id><content type="html" xml:base="https://javax0.github.io/2021/12/08/lambda-and-final-variables.html">&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;1-introduction&quot;&gt;1. Introduction&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Lambda expressions can use the variables in the scope of the lambda expression, but only if they are final or effectively final. What is the reason for that? Why is that? It is an interesting question because the answer is not apparent and opinionated.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;There is only one ultimate answer, though: because that is what the Java Language Specification says. But saying that is boring. True, but boring. I prefer the answer that says lambdas can only use final and effectively final local variables because lambdas are not closures.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In the following, I will discuss what final and effectively final mean, the differences between closures and lambdas, and finally, how we can create closures in Java using lambda expressions. I am not advocating the creation of lambda expression-based closures in Java, nor the abandonment of the idea.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;2-final-and-effectively-final&quot;&gt;2. &lt;code&gt;final&lt;/code&gt; and effectively final&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;When declaring it, a local variable is final if we use the &lt;code&gt;final&lt;/code&gt; keyword. The compiler will also require that the variable get a value only once. This value assignment may happen at the location of the declaration but can be a bit later. There can be multiple lines that assign value to the final variable so long as long only one of them can execute for each method invocation. The typical case is when you declare a final variable without assigning value to it, and then you have an &lt;code&gt;if&lt;/code&gt; statement giving different values in the &quot;then&quot; and the &quot;else&quot; branch.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Needless to say that the variable has to be initialized before the lambda expression is created.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A variable is effectively final if not final, but it could be. It gets an assigned value at the declaration or can get a given value only once.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;3-life-of-a-lambda&quot;&gt;3. Life of a Lambda&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A lambda expression is a kind of anonymous class. The JVM handles it differently, and it is more efficient than an anonymous class, not to mention that it is more readable. However, from our point of view, we can think of it as an inner class.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Anon {

    public static Function&amp;lt;Integer, Integer&amp;gt; incrementer(final int step) {
        return (Integer i) -&amp;gt; i + step;
    }
    public static Function&amp;lt;Integer, Integer&amp;gt; anonIncrementer(final int step) {
        return new Function&amp;lt;Integer, Integer&amp;gt;() {
            @Override
            public Integer apply(Integer i) {
                return i + step;
            }
        };
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;When the lambda expression is created, the JVM makes an instance of the lambda class that implements the &lt;code&gt;Function&lt;/code&gt; interface.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var inc = Anon.incrementer(5);
assertThat(inc.getClass().getName()).startsWith(&quot;javax0.blog.lambdas.Anon$$Lambda$&quot;);
assertThat(inc.getClass().getSuperclass().getName()).isEqualTo(&quot;java.lang.Object&quot;);
assertThat(inc.getClass().getInterfaces()).hasSize(1);
assertThat(inc.getClass().getInterfaces()[0]).isEqualTo(java.util.function.Function.class);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The JVM will place this object on the heap. In some cases, the compiler may realize that the object cannot get out of the method&amp;#8217;s scope, and in this case, it may store it in the stack. It is called local variable escape analysis, which can just put any object on the stack, which cannot escape from the method and may die together with the method return. However, for our discussion, we can forget this advanced feature of the Java environment.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The lambda is created in the method and stored in the heap. It is alive so long as long there is a hard reference to this object and is not collected. If a lambda expression could reference and use a local variable, which lives in the stack, it would need access to something gone after the method returns. It is not possible.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;There are two solutions to overcome this discrepancy. One is what Java follows, creating a copy of the variable&amp;#8217;s value. The other one is creating a closure.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;4-closure-and-groovy&quot;&gt;4. Closure and Groovy&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We will look at Groovy examples when talking about closures. The reason to select Groovy is that it is very close to Java. We will look at some Groovy examples, and for the matter of demonstration, we will use Java-style as much as possible. Groovy is more or less compatible with Java; any Java code can be compiled as a Groovy source. The actual semantic may, however, be different slightly.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Groovy solved the issue of local variable accessibility creating closures. The closure closes the functionality and the environment into a single object. For example, the following Groovy code:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MyClosure {
    static incrementer() {
        Integer z = 0
        return { Integer x -&amp;gt; z++; x + z }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;creates a closure, similar to our lambda expression, but it also uses the local variable &lt;code&gt;z&lt;/code&gt;. This local variable is not final and not effectively final. What happens here is that the compiler creates a new class that contains a field for each local variable used in the closure. A new local variable references an instance of this new class, and the local variable uses all references to this object and its fields. This object, along with the &quot;lambda expression&quot; code, is the closure.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Since the object is on the heap, it stays alive as long as there is a hard reference. The object, which holds the described function has one, so this object will be available so long as long the closure is alive.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def inc = MyClosure.incrementer();
assert inc(1) == 2
assert inc(1) == 3
assert inc(1) == 4&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It is clearly shown in the test execution where the closure increases the &lt;code&gt;z&lt;/code&gt; amount at each execution.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Closures are lambdas with state.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;5-lambda-in-java&quot;&gt;5. Lambda in Java&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Java approaches this problem differently. Instead of creating a new synthetic object to hold the referenced local variables, it simply uses the values of the variables. Lambdas seem to use the variables, but they don&amp;#8217;t. They use only constants copying the value of the variables.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;When designing lambdas, there were two options. I was not part of the team making the decisions, so what I write here is only my opinion, guessing, but it may help you understand why the decision was made. One option could be to copy the variable&amp;#8217;s value when the lambda is created, not caring about the later value change of the local variable. Could it work? Inevitably. Would it be readable? In many cases, it would not be. What if the variable changes later? Will the lambda use the changed value? No, it will use the copied, frozen value. It is different from how variables work usually.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Java requires the variable to be final or effectively final to solve this discrepancy. The disturbing case having the different variable value when the lambda is used is avoided.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;When designing language elements, there are always tradeoffs. On one end, some constructs provide great power to the hands of the developers. However, great power requires great responsibility. Most of the developers are not mature enough to take on the responsibility.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;On the other side of the scale are the simple constructs providing less functionality. It may not solve some problems so elegantly, but you also cannot create unreadable code so easily. Java is usually going this way. There has been an obfuscated C contest almost since the language C started. Who can write less readable code in that programming language? Since then, almost all languages started the contest, except two. Java and Perl. In the case of Java, the contest would be dull, as you cannot write obfuscated code in Java. In the case of Perl, the contest is pointless.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;6-closure-in-java&quot;&gt;6. Closure in Java&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If you want to have a closure in Java, you can create one yourself. The good old way is to use anonymous, or for that matter, regular classes. The other is to mimic the behavior of the Groovy compiler and create a class that encapsulates the closure data.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The Groovy compiler creates the class for you to enclose the local variables, but nothing stops you from making it manually if you want it in Java. You have to do the same thing. Move every local variable that the closure uses into a class as an instance field.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static Function&amp;lt;Integer, Integer&amp;gt; incrementer() {
    AtomicInteger z = new AtomicInteger(0);
    return x -&amp;gt; {
        z.set(z.get() + 1);
        return x + z.get();
    };
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We only had one local variable, &lt;code&gt;int z&lt;/code&gt;, in our example. We need a class that can hold an int. The class for that is &lt;code&gt;AtomicInteger&lt;/code&gt;. It does many other things, and it is usually used when concurrent execution is an issue. Because of that, some overhead may slightly affect the performance, which I abjectly ignore for now.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If there are more than one local variables, we need to craft a class for them.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static Function&amp;lt;Integer, Integer&amp;gt; incrementer() {
    class DataHolder{int z; int m;}
    final var dh = new DataHolder();
    return x -&amp;gt; {
        dh.z++;
        dh.m++;
        return x + dh.z*dh.m;
    };
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;As you can see in this example, we can declare a class even inside the method, and for the cohesion of the code, it is the right place. Eventually, it is easy to see that this approach is working.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;final var inc = LambdaComplexClosure.incrementer();
assertThat(inc.apply(1)).isEqualTo(2);
assertThat(inc.apply(1)).isEqualTo(5);
assertThat(inc.apply(1)).isEqualTo(10);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It is, however, questionable if you want to use this approach. Lambdas generally should be stateless. When you need a state that a lambda uses, in other words, when you need a closure, which the language does not directly support, you should use a class.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;7-summary&quot;&gt;7. Summary&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;This article discussed why a lambda expression can access only final and effectively final local variables.* We also discussed the reason and how different languages approach this issue.* Finally, we looked at a Groovy example and how Java can mimic this.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Therefore, if anyone asks you the interview question, why a lambda expression can access only final and effectively final local variables, you will know the answer. Because the Java Language Specification says so. Everything else is speculation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You an find the code for this article along with the article text source code at &lt;a href=&quot;https://github.com/verhas/demo/tree/master/LambdaFinal&quot; class=&quot;bare&quot;&gt;https://github.com/verhas/demo/tree/master/LambdaFinal&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;comments-imported-from-wordpress&quot;&gt;Comments imported from Wordpress&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;Peter Verhas&lt;/strong&gt; 2021-12-30 21:49:42&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Good catch! I fixed that sentence. It has to be &quot;The JVM will place this object on the heap.&quot;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Thanks.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;Filip&lt;/strong&gt; 2021-12-30 20:46:14&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Is lambda stored on heap or on stack? In paragraph four of &quot;Life of lambda&quot; it is said that lambda is created on a stack, but description is suggesting that it is created on a heap.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;Lambda and final variables - Java Code Geeks - R4 News&lt;/strong&gt; 2021-12-19 14:24:08&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;[&amp;#8230;] Posted on Java Code Geeks with the permission of Peter Verhas, partner of our JCG program. See the original article here: Lambda and final variables [&amp;#8230;]&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;Lambda and final variables &amp;#8211; Java Code Geeks &amp;#8211; Munaf Sheikh&lt;/strong&gt; 2021-12-19 14:30:58&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;[&amp;#8230;] Published on Java Code Geeks with permission by Peter Verhas, partner at our JCG program. See the original article here: Lambda and final variables [&amp;#8230;]&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;Lambda and final variables – Java Code Geeks &amp;#8211; Munaf Sheikh&lt;/strong&gt; 2021-12-19 17:35:51&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;[&amp;#8230;] Published on Java Code Geeks with permission by Peter Verhas, partner at our JCG program. See the original article here: Lambda and final variables [&amp;#8230;]&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content><author><name></name></author><summary type="html">1. Introduction</summary></entry><entry><title type="html">Lambda and Final Parameters</title><link href="https://javax0.github.io/2021/12/08/lambda-and-final-parameters.html" rel="alternate" type="text/html" title="Lambda and Final Parameters" /><published>2021-12-08T00:00:00+01:00</published><updated>2021-12-08T00:00:00+01:00</updated><id>https://javax0.github.io/2021/12/08/lambda-and-final-parameters</id><content type="html" xml:base="https://javax0.github.io/2021/12/08/lambda-and-final-parameters.html">&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;1-introduction&quot;&gt;1. Introduction&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Lambda expressions can use the variables in the scope of the lambda expression, but only if they are final or effectively final. What is the reason for that? Why is that? It is an interesting question because the answer is not apparent and opinionated.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;There is only one ultimate answer, though: because that is what the Java Language Specification says. But saying that is boring. True, but boring. I prefer the answer that says lambdas can only use final and effectively final local variables because lambdas are not closures.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In the following, I will discuss what final and effectively final mean, the differences between closures and lambdas, and finally, how we can create closures in Java using lambda expressions. I am not advocating the creation of lambda expression-based closures in Java, nor the abandonment of the idea.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;2-final-and-effectively-final&quot;&gt;2. &lt;code&gt;final&lt;/code&gt; and effectively final&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;When declaring it, a local variable is final if we use the &lt;code&gt;final&lt;/code&gt; keyword. The compiler will also require that the variable get a value only once. This value assignment may happen at the location of the declaration but can be a bit later. There can be multiple lines that assign value to the final variable so long as long only one of them can execute for each method invocation. The typical case is when you declare a final variable without assigning value to it, and then you have an &lt;code&gt;if&lt;/code&gt; statement giving different values in the &quot;then&quot; and the &quot;else&quot; branch.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Needless to say that the variable has to be initialized before the lambda expression is created.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A variable is effectively final if not final, but it could be. It gets an assigned value at the declaration or can get a given value only once.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;3-life-of-a-lambda&quot;&gt;3. Life of a Lambda&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A lambda expression is a kind of anonymous class. The JVM handles it differently, and it is more efficient than an anonymous class, not to mention that it is more readable. However, from our point of view, we can think of it as an inner class.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Anon {

    public static Function&amp;amp;lt;Integer, Integer&amp;amp;gt; incrementer(final int step) {
        return (Integer i) -&amp;amp;gt; i + step;
    }
    public static Function&amp;amp;lt;Integer, Integer&amp;amp;gt; anonIncrementer(final int step) {
        return new Function&amp;amp;lt;Integer, Integer&amp;amp;gt;() {
            @Override
            public Integer apply(Integer i) {
                return i + step;
            }
        };
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;When the lambda expression is created, the JVM makes an instance of the lambda class that implements the &lt;code&gt;Function&lt;/code&gt; interface.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;var inc = Anon.incrementer(5);
assertThat(inc.getClass().getName()).startsWith(&quot;javax0.blog.lambdas.Anon$$Lambda$&quot;);
assertThat(inc.getClass().getSuperclass().getName()).isEqualTo(&quot;java.lang.Object&quot;);
assertThat(inc.getClass().getInterfaces()).hasSize(1);
assertThat(inc.getClass().getInterfaces()[0]).isEqualTo(java.util.function.Function.class);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The JVM will place this object on the heap. In some cases, the compiler may realize that the object cannot get out of the method&amp;#8217;s scope, and in this case, it may store it in the stack. It is called local variable escape analysis, which can just put any object on the stack, which cannot escape from the method and may die together with the method return. However, for our discussion, we can forget this advanced feature of the Java environment.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The lambda is created in the method and stored in the heap. It is alive so long as long there is a hard reference to this object and is not collected. If a lambda expression could reference and use a local variable, which lives in the stack, it would need access to something gone after the method returns. It is not possible.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;There are two solutions to overcome this discrepancy. One is what Java follows, creating a copy of the variable&amp;#8217;s value. The other one is creating a closure.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;4-closure-and-groovy&quot;&gt;4. Closure and Groovy&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We will look at Groovy examples when talking about closures. The reason to select Groovy is that it is very close to Java. We will look at some Groovy examples, and for the matter of demonstration, we will use Java-style as much as possible. Groovy is more or less compatible with Java; any Java code can be compiled as a Groovy source. The actual semantic may, however, be different slightly.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Groovy solved the issue of local variable accessibility creating closures. The closure closes the functionality and the environment into a single object. For example, the following Groovy code:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MyClosure {
    static incrementer() {
        Integer z = 0
        return { Integer x -&amp;amp;gt; z++; x + z }
    }
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;creates a closure, similar to our lambda expression, but it also uses the local variable &lt;code&gt;z&lt;/code&gt;. This local variable is not final and not effectively final. What happens here is that the compiler creates a new class that contains a field for each local variable used in the closure. A new local variable references an instance of this new class, and the local variable uses all references to this object and its fields. This object, along with the &quot;lambda expression&quot; code, is the closure.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Since the object is on the heap, it stays alive as long as there is a hard reference. The object, which holds the described function has one, so this object will be available so long as long the closure is alive.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;def inc = MyClosure.incrementer();
assert inc(1) == 2
assert inc(1) == 3
assert inc(1) == 4&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It is clearly shown in the test execution where the closure increases the &lt;code&gt;z&lt;/code&gt; amount at each execution.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Closures are lambdas with state.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;5-lambda-in-java&quot;&gt;5. Lambda in Java&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Java approaches this problem differently. Instead of creating a new synthetic object to hold the referenced local variables, it simply uses the values of the variables. Lambdas seem to use the variables, but they don&amp;#8217;t. They use only constants copying the value of the variables.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;When designing lambdas, there were two options. I was not part of the team making the decisions, so what I write here is only my opinion, guessing, but it may help you understand why the decision was made. One option could be to copy the variable&amp;#8217;s value when the lambda is created, not caring about the later value change of the local variable. Could it work? Inevitably. Would it be readable? In many cases, it would not be. What if the variable changes later? Will the lambda use the changed value? No, it will use the copied, frozen value. It is different from how variables work usually.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Java requires the variable to be final or effectively final to solve this discrepancy. The disturbing case having the different variable value when the lambda is used is avoided.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;When designing language elements, there are always tradeoffs. On one end, some constructs provide great power to the hands of the developers. However, great power requires great responsibility. Most of the developers are not mature enough to take on the responsibility.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;On the other side of the scale are the simple constructs providing less functionality. It may not solve some problems so elegantly, but you also cannot create unreadable code so easily. Java is usually going this way. There has been an obfuscated C contest almost since the language C started. Who can write less readable code in that programming language? Since then, almost all languages started the contest, except two. Java and Perl. In the case of Java, the contest would be dull, as you cannot write obfuscated code in Java. In the case of Perl, the contest is pointless.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;6-closure-in-java&quot;&gt;6. Closure in Java&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If you want to have a closure in Java, you can create one yourself. The good old way is to use anonymous, or for that matter, regular classes. The other is to mimic the behavior of the Groovy compiler and create a class that encapsulates the closure data.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The Groovy compiler creates the class for you to enclose the local variables, but nothing stops you from making it manually if you want it in Java. You have to do the same thing. Move every local variable that the closure uses into a class as an instance field.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static Function&amp;amp;lt;Integer, Integer&amp;amp;gt; incrementer() {
    AtomicInteger z = new AtomicInteger(0);
    return x -&amp;amp;gt; {
        z.set(z.get() + 1);
        return x + z.get();
    };
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We only had one local variable, &lt;code&gt;int z&lt;/code&gt;, in our example. We need a class that can hold an int. The class for that is &lt;code&gt;AtomicInteger&lt;/code&gt;. It does many other things, and it is usually used when concurrent execution is an issue. Because of that, some overhead may slightly affect the performance, which I abjectly ignore for now.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If there are more than one local variables, we need to craft a class for them.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static Function&amp;amp;lt;Integer, Integer&amp;amp;gt; incrementer() {
    class DataHolder{int z; int m;}
    final var dh = new DataHolder();
    return x -&amp;amp;gt; {
        dh.z++;
        dh.m++;
        return x + dh.z*dh.m;
    };
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;As you can see in this example, we can declare a class even inside the method, and for the cohesion of the code, it is the right place. Eventually, it is easy to see that this approach is working.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;final var inc = LambdaComplexClosure.incrementer();
assertThat(inc.apply(1)).isEqualTo(2);
assertThat(inc.apply(1)).isEqualTo(5);
assertThat(inc.apply(1)).isEqualTo(10);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It is, however, questionable if you want to use this approach. Lambdas generally should be stateless. When you need a state that a lambda uses, in other words, when you need a closure, which the language does not directly support, you should use a class.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;7-summary&quot;&gt;7. Summary&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;This article discussed why a lambda expression can access only final and effectively final local variables.* We also discussed the reason and how different languages approach this issue.* Finally, we looked at a Groovy example and how Java can mimic this.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Therefore, if anyone asks you the interview question, why a lambda expression can access only final and effectively final local variables, you will know the answer. Because the Java Language Specification says so. Everything else is speculation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You an find the code for this article along with the article text source code at &lt;a href=&quot;https://github.com/verhas/demo/tree/master/LambdaFinal&quot; class=&quot;bare&quot;&gt;https://github.com/verhas/demo/tree/master/LambdaFinal&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content><author><name></name></author><summary type="html">1. Introduction</summary></entry><entry><title type="html">Why and how to do technical interviews?</title><link href="https://javax0.github.io/2021/09/22/why-and-how-to-do-technical-interviews.html" rel="alternate" type="text/html" title="Why and how to do technical interviews?" /><published>2021-09-22T00:00:00+02:00</published><updated>2021-09-22T00:00:00+02:00</updated><id>https://javax0.github.io/2021/09/22/why-and-how-to-do-technical-interviews</id><content type="html" xml:base="https://javax0.github.io/2021/09/22/why-and-how-to-do-technical-interviews.html">== 1. Why and how to do technical interviews?

__It is a personal blog. The views and opinions expressed in this article are those of the author. They do not represent people, institutions, or organizations that the author may or may not be associated with in a professional or a personal capacity. All information is provided on an as-is basis.__



Technology companies are growing and need new personnel. In addition, there is natural attrition in the companies. In a highly competitive market, people are leaving for various reasons, and these needs also have to be met through hiring new employees. Therefore, searching for, selecting, and hiring new co-workers are always a must - it is a standard business for every company.



Companies usually conduct interviews to assess and select their future colleagues from the pool of aspiring candidates. Even though it is the standard practice, there are a lot of controversies with this approach. You can see many social media posts about harmful practices, wrong questions, and ill-treatment of the candidate. One infamous example was when Google asked candidates in their interviews to estimate the number of golf balls that could fit in a bus.



Most of the people having a voice on social media express their opinion that this was total misuse. I tend to see some merit in using such questions, but, as often, personal opinions are irrelevant. So instead of starting a debate about this particular question or similar questionable practices, I will focus on the purpose and the practical approaches we apply when conducting interviews.



I mainly rely on the experiences I gained when completing interviews on behalf of my current employer, but I believe there is nothing company-specific in this article.



When I write &apos;we&apos;, I refer to the whole industry or at least to a large group of companies that follow good practice and not specifically to my employer.




=== 1.1. What is the purpose of conducting interviews?




Any company could hire a candidate without any prior filtering, but this could cost them a lot. Suppose the candidate does not fit the company or meet the criteria to be successful in a position. In that case, the company would have to pay the salary for the probation period, colleagues guiding the new hire during the onboarding process would invest significant time and effort, and other resources, like office space, infrastructure, heating, network, and so on, that also costs money. It is not a good practice for a company.



However, the money the company loses is not the main issue. Companies have profit and loss, and you can consider the cost of selecting the right candidate as an investment. The highest cost is not monetary, and it is not on the company side. The candidate is the one who would pay the real price for such a practice.



Most of the candidates have a safe job and solid position when looking for a new one. However, losing the place at the new job, getting sent away is a substantial personal burden. As a result, candidates may find themselves &quot;in the street&quot; looking for a new position. Not having a current job is hard to explain during the HR interviews. At the same time, the financial burden and the time pressure may also put the candidate into a hard-to-negotiate corner during the salary discussions.
No company should do this to anyone. If a company wants to hire you without proper assessment: run. Fast and far away.



The thorough assessments of the candidates&apos; skills, experience, and knowledge are at the other end of the spectrum. Some companies do that by giving out homework, completing full-day assessments filled with role plays, coding tasks, and using other similar techniques to evaluate candidates. The simplest and cheapest way to do an evaluation, however, is an interview.



A full-day assessment almost certainly gives a more reliable result, but it requires significant resources from the company. So, as usual in business, we should follow the Pareto principle and shoot for the cheapest good-enough solution. I will talk a bit later about what ‘good enough’ is.



Overcomplicated hiring processes may distract candidates. Imagine a senior developer who is looking for a new position. How many full-day assessments will they attend? To participate in such a selection, candidates may need to use a vacation day from their holiday budget, and they have to keep it secret at the actual workplace. If your competitor offers you a late afternoon interview instead, you will most probably choose that option.



There are pros and cons. We cannot tell what the best approach is, and certainly, doing interviews as a selection tool is not the imaginable best, but probably the best existing, and indeed the best we know. Nevertheless, it is the industry standard practice.




=== 1.2. What is a good interview?




We do not need to complete the best interview in the world, as I wrote above. We have to complete one that is good enough. To say that, we have to know what we consider to be a good interview. We should have a metric that can tell us which interview is &quot;better&quot;.



Candidates often tell me: &quot;This was the best interview of my life.&quot;, even when my conclusion is not to recommend them for hire. Although a happy candidate is essential in bringing your company a good image, it is not the metric we usually look for. A good interview does not need to be enjoyable for the candidate. That is just an extra, a possible byproduct of a good interview.



An interview&apos;s most crucial quality measure is to differentiate a fitting candidate from a non-fitting one. Of course, there are other criteria, like proper communication, politeness, non-disclosure, and conduct. These are all very important. Nevertheless, the primary goal of the interview is the selection.



When doing an interview, there are four possible outcomes. The candidate can be fitting or non-fitting, and at the same time, the interviewer recommends or does not recommend the candidate for hire. These are two dimensions with two values each. Each pair is possible, resulting in the four possible outcomes.



The recommended fitting candidate and the non-recommended non-fitting candidates are the most uncomplicated cases. These are the happy paths.



The remaining two cases, false positive and false negative, are a bit more tricky. The case when the interviewer does not recommend the candidate, although they are fitting, is theoretical. Those candidates do not get employed, and none will discover their fitness. In other words, we will never know when a candidate and/or an interview fall into this category. This case is theoretical in the sense that though it certainly exists, we will never see it.



When a candidate is recommended but not fitting is the costly situation we already discussed. When it happens, it will be clear for many people in the company who will manage the consequences and deal with the problem.



The solution for the situation is often to find a better, more suitable position for the person inside the company. It is done falling into the trap of the sunk cost fallacy. The people involved subconsciously feel the relative cost and burden of finding a new position without an existing need and actual vacancy. This cost is born to the candidate. Feeling responsible for the situation, they do not want to put that on them.



When the company has a good hiring and interviewing practice, it rarely happens. We cannot avoid such situations, however. It is not because of the unique nature of the interviews. It is a general measurement theory. Any decision can have four outcomes: true-positive, true-negative, false-positive, and false-negative. No decision system could avoid the false parts. They exist by principle. The only thing we can tune is to push the scale between the false outcomes. What do we want to have less? Is it the false positive or the false negative result which is less desirable?



At this point, you can tell that I am advocating against the false positive cases, which means that we have to design the interview decisions to avoid those even if we get more false-negative results.



This advocation is not general, though. It is only for the interview decisions. For example, a cancer screening system should be scaled towards favoring false-positive cases. I would rather choose a few days of panic until the repeated test annuls the false-positive result than die because of a false-negative result not detecting the tumor at an early stage.



The fact that we should favor the false-negative cases means that the technical interviewers should recommend hiring only those candidates they are absolutely sure about. When there is any doubt that the candidate is bad, they are better not to be hired.



Note that by doing so, you will filter out some candidates who are good enough but are not very good. You have your doubts not without reason. The potential loss is insignificant in sending away some of the candidates who would fit but are not &quot;really good&quot;.




=== 1.3. Do we judge the candidate?




Avoid judging the candidate is extremely important. In the previous section, I deliberately used &quot;good candidate&quot; and &quot;bad candidate&quot;. In addition, I used an example (medical screening) that subconsciously compared candidates to cancer. If you felt inappropriate when you first read that, you are on the right track. If not, you have to think about why you did not.



We must respect the candidates.



Technical interviewers have to be humble. Maybe non-trivial at first, but we also must not evaluate the person, and we should not use expressions that may even unintentionally imply that. You cannot do that if you look down on candidates and you do not respect them. The respect has to be authentic. If it is not, you cannot hide it. So the first thing is that you should feel and show genuine care and then work on your communication.



It is why I prefer to use the word &quot;assess&quot; instead of &quot;judge&quot;. We assess the knowledge, skills, and experience of the candidate. We do not &quot;judge&quot; these, even though linguistically, it would mean the same. For the same reason, I usually talk about the position fitting the candidate and not the candidate fitting the position. Thus, when I say that a position is not good for a specific candidate, nobody will think that it is generally bad, even less that it is stupid or dumb.



On the other hand, the sentence &quot;The candidate is not good for the position.&quot; is heard and interpreted as &quot;The candidate is not good…&quot; The end of the sentence often gets lost in the communication or during the interpretation. It has to be carefully avoided.



Sometimes, I meet lead developers, senior, or even architect candidates who lack even basic skills in their current employment. Even though I feel the temptation to doubt whether their current status is well justified, I don&apos;t. If a candidate’s current position seems to be a lie in the CV, it does not matter. Companies are different, and they need different types of people. There is no such person who is generally not fitting a role. To assess a person&apos;s fitness for a position, you have to compare the person&apos;s qualities to the role. Otherwise, you could plainly say that the candidate is ok but can not tell us for what.




=== 1.4. Work with the Candidate




When conducting the interview, you work with the candidate. The candidate helps you, and you help the candidate. To get a clear picture and understand whether the position is really the dream position for the candidate is in your mutual interest.



It means that you can be absolutely honest with the candidate. You can tell them all the things that I wrote in this article. You can explain the aim of the interview, what the possible outcomes are, the recommended and not recommended decisions, and so on.



I usually devote 7 minutes at the start of the interview explaining the above. Of course, it is a bit boring after several hundreds of interviews, but every job has its downsides and upsides, and it is crucial for each candidate.



You can even explain that when candidates are lying or cheating candidates, it might be harmful. It helps when a candidate gets a coding exercise that is too familiar to them. A few times, the candidate proactively warned me that they had already met the task beforehand. So we chose a different one.




=== 1.5. Coding Exercise




The above paragraphs are generally valid for all types of interviews and not specific for software development. For example, doing a coding exercise is specific to technical software developer interviews. However, most of the debates on social media are related to this practice. The reason for that is simple. It is very easy to do it wrong.



I would never recommend a candidate who cannot demonstrate the coding skills in an interview. After all, what is the value a developer can deliver who cannot code? It is more questionable if a solution architect needs to code, and I would not get into that this time. I have my personal opinion about it, but it is irrelevant. Maybe I will discuss it in a different article.



I have met some developers hired from different vendors working in the same team for our clients who could not code. We never complained, and we did the extra work instead of them. The client personnel could see who did what and came to their conclusions most of the time. I will also not name the vendor ever. Let&apos;s just say that these developers stay afloat in the industry until they find a different job and become BAs, PMs, or car salesmen. I accept them as a fact of life, but I do not accept hiring one in my workplace. In conclusion, we should agree that some performance measures are needed to assess the coding skills as a work theory.



An excellent coding exercise helps assess three things:



* The algorithmic thinking of the candidate.* Coding skills and the muscle memory of the language we test. In my case, it is Java.* Communication skills.



Each of these can easily go wrong, and hence negative stories quickly get to social media.



It is challenging to assess algorithmic thinking. It is much easier to test if the candidate can solve one specific problem or complete a task. That way, the assessment quickly degrades to testing if the candidate knows the particular algorithm. Even though I believe that learning and understanding the most important algorithms and data structures (quick sort, balanced trees, graph traversing) is vital for a developer, many developers do not possess even the fundamental computer science theory. I can also accept that there is no value in knowing many algorithms by heart. It is better to have the skillset to create the algorithm when needed.



To avoid testing the candidate knowing the task instead of solving it, I have several of them you cannot find on the internet. (Fun story about that at the end of the article.) We also discuss the solution while the candidate forges the code step by step. I realize if the candidate has known the algorithm beforehand.



You can test the coding skills easily. Many typical coding practices show off an inexperienced coder.



You can spot old coding constructs that we are not using anymore as the language (in my case, Java) develops. I sometimes see explicit type boxing, which we do not use since Java 1.4 Junior developers tend to compare a boolean value with &apos;== true&apos; or write an &apos;if&apos; statement and return &apos;true&apos; and &apos;false&apos; literal values from the execution branches. Some developers make mistakes, like indexing a &apos;String&apos; as if it was an array.



As an interviewer, you should interpret those with a pinch of salt. The interview is not a normal coding environment. It is much more stressful, and such mistakes are many times caused by stress. The technical tools are usually less advanced than the usual IDE, with less support for code completion, syntax checking, and so on. Do not expect the candidate to know all the JDK API calls from the top of their head.



You can also check communication skills. For example, some candidates blamed me for presenting unprecise, even sloppy task descriptions. They were surprised when I told them that I was aware of that. It is to test if they clarify the task before making bold assumptions and just immediately start coding. Most of them do.



The coding exercise is the most challenging part of the interview. Not for the candidate, though. It is for the interviewer. It is a task that the candidate has to do together with you. If you, as an interviewer, see that the candidate is working on the coding task alone, you are doing it wrong. If you work together, then it is good. It may not be perfect, but most of the usual pitfalls you have already avoided.




=== 1.6. Giving Feedback




At the end of the interview, you will know whether to recommend or not to recommend the candidate. If you don&apos;t know, if you are not absolutely sure, then you should not recommend the candidate. I wrote that you must not recommend someone you are not sure about.



The recommendation, usually along with detailed analysis, is the primary outcome of the interview. There can be, however, another valuable byproduct. You can give valuable feedback to the candidate.



Interviewers seldom give feedback about the interview to the candidates, and this is not a good practice. I do not advocate giving feedback no matter what because it is a double-edged sword. If you provide feedback in the wrong way, it may cause a lot of harm to the candidate and the company. Providing valuable, thoughtful, and relevant feedback required some special skills.



Good feedback emphasizes the candidate&apos;s strong points that they can build on and highlights the things that they can improve and that may result in enormous benefits.



The most benefit is evidently for the candidate, but it is also valuable for the company. Getting detailed feedback is always an invaluable help to better ourselves. Good feedback, however, is also beneficial for the company. Even if rejecting a candidate is the correct conclusion, a blatant and unexplained refusal may induce bad feelings towards the company. Feedback can mitigate this risk. Feedback explains the reasons so that the candidate can learn the reasons along with suggestions for improvement. Again, you can emphasize that the refusal is not a judgment; it solely recognizes the incompatibility between the candidate’s skills, experience, or knowledge and what the company requires in a specific role.



You do not know each other. Thus, you have to put a lot of emphasis on the good things that the candidate can build on. You can also explain that the feedback is limited as it is based on a 60-minute interview only.



Some candidates challenge some of my statements during the feedback. It is pointless from the feedback point of view. If I made a mistake, I misread the candidate in some aspect; they can ignore that part of the feedback. Some of the comments may likely be wrong due to the limited nature of the session. At the same time, I give feedback after the decision. It would be best if you did not change the decision based on any feedback debate. Even though I am usually lenient with candidates arguing about some points of the feedback. It reveals a lot about their personality that I can include in the subjective part of the interview record, and at the same time, it helps them vent their feelings.



I had candidates referred to our company by his friend I rejected but sent away with friendly but honest feedback.




=== 1.7. Summary and Fun Story




Navigare necesse est. Doing interviews is unavoidable. Vivere no est necesse. Doing good interviews is difficult. In this article, I wrote about some aspects of the interviewing. There are other aspects that I did not discuss. Those I may address in a later article. I also know that many aspects of this topic are opinionated. You are welcome to comment, rant, criticize and tell the truth as you feel fit.



I promised you a fun story, so here it is.



Once I interviewed a candidate who was not outstanding. He had several knowledge gaps related to basic Java. He knew a few things wrong and was a bit stubborn. His coding skills were also less than what we required. When I ended the interview, I asked him if he wanted feedback. He said no, and disconnected the communication. (We usually do remote interviews using IP communication tools, like Zoom, Teams, Skype, etc.)



He immediately wrote an eMail to the talent acquisition team claiming that I was asking him wrong; I did not accept his correct answers and stating that I did not know Java. He also wrote that I was giving him a coding task that anyone can find on the internet, and I did not accept his correct solution because I did not like him. Even though he did not agree to video recording, the coding exercise does get recorded to crosscheck. I did not doubt that the solution was wrong, but his statement that I allegedly copied the exercise from the internet bothered me. So I googled some of the sentences of the task. I could find it on a site along with a wrong solution he also provided. It was word by word the same, including a typo. So you can guess who was copying from whom.



Your coding exercise tasks leak out. So you have to replace them frequently.</content><author><name></name></author><summary type="html">1. Why and how to do technical interviews?</summary></entry><entry><title type="html">Creating a JUnit 5 ExecutionCondition</title><link href="https://javax0.github.io/2021/05/04/creating-a-junit-5-executioncondition.html" rel="alternate" type="text/html" title="Creating a JUnit 5 ExecutionCondition" /><published>2021-05-04T00:00:00+02:00</published><updated>2021-05-04T00:00:00+02:00</updated><id>https://javax0.github.io/2021/05/04/creating-a-junit-5-executioncondition</id><content type="html" xml:base="https://javax0.github.io/2021/05/04/creating-a-junit-5-executioncondition.html">== 1. Introduction


https://youtu.be/z9NL_Il0AQI

JUnit 5 has a lot of underutilized features. Developers have learned how to use JUnit 4, and they utilize the same feature set when using JUnit5. The sexy `DisplayName` annotation is used more and more, but the majority of the new features developers skip. In this article, I describe a particular situation I was facing and how I solved the issue by creating a custom `ExecutionCondition`.


== 2. My Special Testing Need


I am developing Jamal, which is a general-purpose transpiler, text macro language. It converts from an input text to an output text, resolving and executing macros in the text. Sometimes macros can be overcomplicated, and it may not be trivial why the output is what we get. The first approach to this issue is not to use overcomplicated structures, but this is not how developers work. Good developers tend to use the tools they have in their hands to the total capacity.

In the case of Jamal, it needs debugging. Jamal supported debugging for a long time, dumping each atomic step into an XML file that the developer can later examine. It is, however, not as effective as interactive debugging.

To support interactive debugging, I developed a debugger interface into release 1.7.4 accompanied by a Rest.js client application. Jamal starts in debug mode if it sees an environment variable `JAMAL_DEBUG` or system property `JAMAL_DEBUG_SYS`. When this variable is defined, Jamal pauses whenever it starts processing a new input and listening on a port configured by the variable. It goes on with processing only when it gets a command through the TCP channel.

The important thing for this article is: Jamal pauses and starts to listen on a TCP port in this mode.

The big question is, how to debug the debugger? The obvious answer is: Start Jamal in debug mode in a JVM started in debug mode. The easiest way in IntelliJ is to start it from a JUnit test by clicking on the debug button. So I had the test:

[source,java]
----
@Test
@DisplayName(&quot;Used to debug the debugger UI&quot;)
void testDebugger() throws Exception {
    System.setProperty(Debugger.JAMAL_DEBUG_SYS, &quot;http:8081?cors=*&quot;);
    TestThat.theInput(
        &quot;hahóóó\n&quot;.repeat(2) +
            &quot;{@define a=1}{@define b(x)=x2x}{b{a}}&quot;
    ).results(&quot;hahóóó\n&quot; +
        &quot;hahóóó\n&quot; +
        &quot;121&quot;);
    System.clearProperty(Debugger.JAMAL_DEBUG_SYS);
}
----


You have to `//@Test` the code before committing to your repo. Forgetting that will break the build because when it starts, it pauses and waits. I forget to comment out the annotation because I am such a forgetful person. Maybe age, maybe something else. However, my experience is that every developer has age, and every developer forgets to comment out such a thing. I needed something that realizes that the test is started from IntelliJ and lets it run but aborts it otherwise.


== 3. How to Recognize it is IntelliJ?


When you run a unit test from IntelliJ, IntelliJ will invoke your code from IntelliJ. Not directly. It goes through a few method calls in the stack, but there should be some class that belongs to IntelliJ towards the top of the stack. If the method and the class belong to IntelliJ, then the name of the class should undoubtedly have something specific in it we can check. Generally, this is the idea.

No specifications guarantee it. The name of the classes IntelliJ uses may change from time to time. Like Maven or Gradle, a different execution environment can also use some class names that may be similar to that of IntelliJ. But this is a solution that eventually works. No guarantee, but as for now, it works.

[source,java]
----
boolean isIntelliJStarted = false;
final var st = new Exception().getStackTrace();
for (final var s : st) {
    if (s.getClassName().contains(&quot;Idea&quot;)) {
        isIntelliJStarted = true;
        break;
    }
}
----


The selection of the string `Idea` to check is more or less arbitrary. It is a string that is not likely to happen in the stack trace of some other application, and at the same time, there is only a tiny chance that it disappears from later IntelliJ versions. It is also to note that creating the stack trace this way is time-consuming. When the code runs from IntelliJ, it is not a problem at all. The time it needs is way less than a fraction of a second, and the next step I have to do after I started the application is opening a browser and the debugger web page. By the time I am finished with that, Java could have analyzed the stack trace a few million times. I, as a human, am much slower than the stack trace gathering.

When the code runs on the CI/CD or Maven on the command line, the delay is considerable. It is not tremendous or really significant, but it should be considered. It adds to the compile time.

I would not use such a solution in a performance-sensitive production code.


== 4. Separation of Concern


I could insert this code into the test and return it from the test if it is not executed from IntelliJ. I did that as a first try, but I was aware that this is not an amicable solution. To make a decision separating the environments is not the responsibility of the test.

I was sure that JUnit 5 has a better solution for this. I asked `@RealityInUse` (Twitter handle) to help me. I was in a lucky situation because we share an office, which happens to be our living room during the pandemic. He is an active contributor of JUnit Pioneer https://junit-pioneer.org project of ``@nipafx`, he knows a lot about JUnit 5 extensions. (And he is my son.)

He told me that what I needed was an `ExecutionCondition`.

`ExecutionCondition` is an interface. It defines one single method with a direct signature:

[source,java]
----
ConditionEvaluationResult evaluateExecutionCondition(ExtensionContext ctx);
----


The implementation should have a method overriding this interface method, and after doing the above stack examination, it has to

[source,java]
----
return isIntelliJStarted ?
    ConditionEvaluationResult.enabled(&quot;started from IntelliJ&quot;) :
    ConditionEvaluationResult.disabled(&quot;not started from IntelliJ&quot;);
----


It is almost all the work to be done. There is one little thing left: tell JUnit to use this condition for this test.

To do that, we created an abjectly named annotation: `@IntelliJOnly`. With this, the class we developed was the following (without imports):

[source,java]
----
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
@ExtendWith(IntelliJOnly.IntelliJOnlyCondition.class)
public @interface IntelliJOnly {

    class IntelliJOnlyCondition implements ExecutionCondition {
        @Override
        public ConditionEvaluationResult evaluateExecutionCondition(ExtensionContext context) {
            final Method method = context.getRequiredTestMethod();
            final var annotation = method.getDeclaredAnnotation(IntelliJOnly.class);
            if (annotation == null) {
                throw new ExtensionConfigurationException(&quot;Could not find @&quot; + IntelliJOnly.class + &quot; annotation on the method &quot; + method);
            }
            boolean isIntelliJStarted = false;
            final var st = new Exception().getStackTrace();
            for (final var s : st) {
                if (s.getClassName().contains(&quot;Idea&quot;)) {
                    isIntelliJStarted = true;
                    break;
                }
            }
            return isIntelliJStarted ? ConditionEvaluationResult.enabled(&quot;started from IntelliJ&quot;) : ConditionEvaluationResult.disabled(&quot;not started from IntelliJ&quot;);
        }
    }
}
----


The test with this annotation is the following:

[source,java]
----
@Test
@DisplayName(&quot;Used to debug the debugger UI&quot;)
@IntelliJOnly
void testDebugger() throws Exception {
    System.setProperty(Debugger.JAMAL_DEBUG_SYS, &quot;http:8081?cors=*&quot;);
    TestThat.theInput(
        &quot;hahóóó\n&quot;.repeat(2) +
            &quot;{@define a=1}{@define b(x)=x2x}{b{a}}&quot;
    ).results(&quot;hahóóó\n&quot; +
        &quot;hahóóó\n&quot; +
        &quot;121&quot;);
    System.clearProperty(Debugger.JAMAL_DEBUG_SYS);
}
----



== 5. Notes


The implementation of the condition checks that the test method is annotated by `@IntelliJOnly`. The annotation may not be there if the user (developer using the annotation) makes some mistake, invokes the condition in the wrong way. This extra check may save a few surprises for the developer using this condition.


== 6. Summary


In this article, I described a situation that needed conditional test execution with a particular condition. After that, I described how the condition could be evaluated. Finally, we created a JUnit 5 execution condition to separate the Hamletian &quot;run or not to run&quot; dilemma from the test code.

As a takeaway, you should remember that JUnit is way better than JUnit 4. Utilizing only the features, which were already available in version 4, is a waste of resources. Your tests can be much simpler, more expressive, and easier to maintain if you learn and utilize the programming features of JUnit 5. Do!</content><author><name></name></author><summary type="html">1. Introduction</summary></entry><entry><title type="html">Automate Technical Documentation using Jamal</title><link href="https://javax0.github.io/2021/02/17/automate-technical-documentation-using-jamal.html" rel="alternate" type="text/html" title="Automate Technical Documentation using Jamal" /><published>2021-02-17T00:00:00+01:00</published><updated>2021-02-17T00:00:00+01:00</updated><id>https://javax0.github.io/2021/02/17/automate-technical-documentation-using-jamal</id><content type="html" xml:base="https://javax0.github.io/2021/02/17/automate-technical-documentation-using-jamal.html">&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;1-introduction&quot;&gt;1. Introduction&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Writing good technical documentation is an art.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;An art is the expression or application of human creative skill and imagination, &amp;#8230;&amp;#8203; to be appreciated primarily for their beauty or emotional power.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;But every art, like sculpting, has a craft part. You need chisels, hammers to form the sculpture out of the blob of marble. You need to learn the craft to master the art. Technical documentation writing is similar.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Writing sentences that are easy to read, entertaining for the reader is the art part. Fixing typos and grammatical errors is more like a craft. Making the documentation precise, to the point, and well structured is also the craft part. Crafts can be learned and aided with the right tool.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In technical documentation writing, the tools help address those tasks that are often performed manually though they could be automated. In this article, I will write about a tool that helps in that manner and which I used successfully to write documentation, many articles&amp;#8201;&amp;#8212;&amp;#8201;also this one --and books.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;2-what-can-be-automated&quot;&gt;2. What can be automated&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Many things can be automated for technical document writing. I tried to gather a list from my experience, but it may not be complete. The list is the following:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/verhas/jamal/master/jamal-snippet/articleimages/tasks.svg&quot; alt=&quot;tasks&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Eliminate manual text repetition.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Transclude information from the documented system.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Checks internal consistency of the documentation.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Check the consistency of the documentation with the documented system.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In the following, I will talk shortly about these tasks, and then I will explain the tool that I use to address these.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;2-1-dry-in-documentation&quot;&gt;2.1. DRY in Documentation&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The DRY (Don&amp;#8217;t Repeat Yourself) is a fundamental and old principle in programming. If there are the same lines in the source, they should be singled out, moving the common code into a separate method, class, or other coding structure. Copy/Paste programming is evil and must not be done. It does not mean that there is no repeated code in the compiled binary code. Code generators are free to repeat code if they think that is better than in some way eliminating it. One famous example is when a short loop is extended, and the code is repeated instead of creating a binary looping construct. It may consume more memory, but at the same time, optimization may find it faster.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The same should happen when you write the documentation. Except, you do not have methods or classes in the documents. You can reorganize your document into smaller sections, and then you can refer to the areas. It may have an impact on the readability. If the reader has to turn the pages instead of linear reading, comprehending the document becomes challenging. Using non-printed, non-linear documentation, a.k.a. hypertext eases a bit the page-turning, but the reader still can get mentally lost in the maze of the non-linear documentation. The ideal solution would be to have documentation, which is linear and contains all the interesting text for the particular user, reading it in the order as they want to read it.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Eventually, it is impossible. With today&amp;#8217;s technology, you cannot create a document that contains precisely what the reader wants to read at the very moment and changes for each reader and even for each reading. The best approach we have is repeating some of the text in the documentation. Some readers may find it boring, while others will just get what they need. Your document &quot;source&quot; should be DRY, and the repeating of the text, the copy-paste operation has to be automated. The advantage is: any change in the text is consistently propagated to every occurrence of the text.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;2-2-information-transclusion&quot;&gt;2.2. Information Transclusion&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A living document has to follow the change of the system it documents. In the case of software, this can partially be automated. A lot of data that may need to be included in the document is available in the source code. For example, the current version of the application, a numeric value, may be included in the documentation at different locations. Updating it to the latest version manually is almost always some error. Sooner or later, one or more references may skip the update and become stale. The solution is partial when we use the technique that eliminates DRY. We define the version in the document in one place, and it will be referred to in other places. It still needs that one place to be updated. Fetching the version number from the source code automatically is one level more automation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Usage samples are also an excellent example for transclusion. When the usage samples are automatically fetched from the unit tests, they are guaranteed to run during the test execution.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;2-3-internal-consistency&quot;&gt;2.3. Internal Consistency&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Ensuring internal consistency of the document can also be automated to some level. It is such an essential factor that many documentation systems support it related to cross-references. The examples can be various.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You may create a document with use cases. In the use cases, you use actors in the description. A document management system can ensure that all the actors used in the document are also defined. A similar check can be done for abbreviations and other things. Consistency, if it can be formally defined, can be checked by automated tools.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;2-4-external-consistency&quot;&gt;2.4. External Consistency&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Just as well as the different parts of the document should be consistent and without contradiction, the documentation should also be consistent with the system it documents. It is similar to transcluding information from the source. The difference is that the information, in this case, is mainly existence only. For example, you reference a file, a directory, a method in a Java class. A tool can check that the directory, file, or method exists; it was not renamed nor deleted. Similarly, other consistency checks can be programmed.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;3-document-writing-is-programming&quot;&gt;3. Document Writing is Programming&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;There may be some other cases where some automation may come into the picture. The general approach, however, should be to manage the document similar to the program source. Technical documents need maintenance. Documents have a source, and they should be structured. One change in the documented system should be followed by a single change in the document. Every other occurrence in the output should be created automatically.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It is very much similar to programming. The programmers write source code in a high-level programming language, and the compiler generates the machine code. Sometimes the compilation process is a long chain involving many tools. Programming in machine code is an art of the past. The advantages of using a high-level language fairly compensate for the extra effort using the compiler chain.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In technical documentation, the advantages, at least in the short run, are not so appealing. Creating a document using some WYSIWYG editor is easy as opposed to programming in assembly. It is easy to lure the technical writer to avoid some extra work at the start and avoid the document source code creation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A work to be done tomorrow is always cheaper today than the avoidable work of now.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The same will not be true tomorrow. Creating the more complex but less redundant documentation source almost always payback, especially if we consider document quality coming from consistency and up-to-date-ness.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/verhas/jamal/master/jamal-snippet/articleimages/cost.svg&quot; alt=&quot;cost&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;4-the-tool-java-macro-language&quot;&gt;4. The Tool: Java Macro Language&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In the rest of this article, I will describe a tool that can automate document management tasks. The tool is the Java version of the text processor Jamal. Originally the name was standing for Just Another Macro Language, and it was created in the late 1990-ies in Perl. A few years ago, I rewrote the implementation in Java, with the original functionality enhanced. Since the application is based on Java, it is now named Java Macro Language, abbreviated as Jamal.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The basic concept of Jamal is that the input text containing free text and macros mixed is processed. The output is a text with all the macros executed and evaluated. The syntax of the macros is free. The only requirement is that each of them starts and ends with a specific string. The start and end string can be defined when the macro processor is initialized. It can also be changed on the fly in the input text. When I document Java programs, then I usually use &lt;code&gt;{%&lt;/code&gt; as start string and &lt;code&gt;%}&lt;/code&gt; as end string. That way, a simple macro definition will be&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;{%@define lastUpdated=2021-02-17 16:00%}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Later you can refer to this macro as&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;{%lastUpdated%}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;and it will be replaced by the value &lt;code&gt;2021-02-17 16:00&lt;/code&gt; for each use.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Jamal distinguishes user-defined and built-in macros. The example above, named &lt;code&gt;lastUpdated&lt;/code&gt; is a user-defined macro, as it is defined in the input text. The macro defining it, named &lt;code&gt;define&lt;/code&gt; is built-in. It is implemented as a Java class implementing the Jamal &lt;code&gt;Macro&lt;/code&gt; interface. The built-in, Java implemented macros are provided in JAR files, in libraries. The core package contains the essential macros, like &lt;code&gt;define&lt;/code&gt;, &lt;code&gt;import&lt;/code&gt;, &lt;code&gt;begin&lt;/code&gt;, &lt;code&gt;end&lt;/code&gt;, &lt;code&gt;options&lt;/code&gt;, &lt;code&gt;comment&lt;/code&gt;, and a few others. These macros are not task-specific. They are needed generally.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Other libraries, like the &lt;code&gt;jamal-snippet&lt;/code&gt; library, contain macros that support some specific task. The mentioned &lt;code&gt;jamal-snippet&lt;/code&gt; library supports document management.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;4-1-snippet-handling-transclude&quot;&gt;4.1. Snippet Handling, Transclude&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The original idea of the snippets is not new. The basic approach to use the source code as part of the documentation originates from D. Knuth with Web and Tangle as early as 1984. &lt;a href=&quot;https://en.wikipedia.org/wiki/CWEB&quot; class=&quot;bare&quot;&gt;https://en.wikipedia.org/wiki/CWEB&lt;/a&gt; Creating a program that contains the documentation and the execution code did not become popular as it needed a lot of extra work from the developers and an additional compilation step. The current trend includes the documentation into the source code as a comment. In the case of Java programs, this is JavaDoc. It is also a trend to use unit tests as a form of documentation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The two are separate, and both lack the aspect that the other provides. JavaDoc does not show sample use unless someone copies some sample code into it manually. The unit test does not contain a proper explanation unless someone copies fragments or the whole from the JavaDoc to the unit test comments. JavaDoc is converted to navigable HTML pages. Unit tests are source code. Although the best documentation is the source code, it would be nice to have a better, more document-like format.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;When we talk about snippets, then we copy code fragments automatically into the documentation. In practice, the documentation format is Asciidoc or MarkDown these days. Both formats allow code samples in the document.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;using Jamal, the snippets can be marked in the Java source code or any other source code with&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;    snippet snippetName
    end snippet&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;lines. The &lt;code&gt;snippetName&lt;/code&gt; should be replaced by a unique name that identifies the snippet, and all the lines between the &lt;code&gt;snippet&lt;/code&gt; and &lt;code&gt;end snippet&lt;/code&gt; lines will be the snippet itself. The snippets are gathered using the &lt;code&gt;{%@snip:collect directory%}&lt;/code&gt; macro. Here &lt;code&gt;directory&lt;/code&gt; is either a directory or a single file. The collection process reads each file and collects the snippets. After this the snippets can be referenced using the &lt;code&gt;{%@snip snippetName%}&lt;/code&gt; macro. When Jamal runs, the macro is replaced with the actual value of the snippet. It ensures that the code sample in the documentation is up-to-date.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Other macros can trim the content, replace some strings in the samples, number the lines, skip some lines, and so on. With these, you can include any code sample.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Snippets are suitable for code samples, but not only for code samples. As JavaDoc is included in the source code, some parts of the documentation can also be included in the code as comments.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;For example, the implementation of the macro &lt;code&gt;directory&lt;/code&gt; contains the following lines:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;    // snippet dirMacroFormatPlaceholders
    &quot;$name&quot;, name, // gives the name of the directory as was specified on the macro
    &quot;$absolutePath&quot;, dir.getAbsolutePath(), // gives the name of the directory as was specified on the macro
    &quot;$parent&quot;, dir.getParent() // the parent directory
).and(
    &quot;$canonicalPath&quot;, dir::getCanonicalPath // the canonical path
    //end snippet&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;These lines list the different placeholders and their values that the built-in template handler knows. The documentation includes this snippet with the following lines:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;{%@define replace=|^.*?&quot;(.*?)&quot;|* `$1`!|!.*?//||%}
{%@define pattern=\)\.and\(%}
{%#replaceLines{%#killLines{%@snip dirMacroFormatPlaceholders %}%}%}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;(Note: the actual version is a bit more complicated, as you will see later.) It inserts the content of the snippet evaluating the &lt;code&gt;snip&lt;/code&gt; macro. The content of the sippet is then passed to the macro &lt;code&gt;killLines&lt;/code&gt;. This macro will delete all the lines that match the regular expression defined in the macro &lt;code&gt;pattern&lt;/code&gt;. The result is still further modified by the &lt;code&gt;replaceLines&lt;/code&gt; macro. It executes the Java String &lt;code&gt;replaceAll()&lt;/code&gt; method on each line with the arguments defined in the macro &lt;code&gt;replace&lt;/code&gt;. The final result, inserted into the output is:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;* `$name` gives the name of the file as was specified on the macro
* `$absolutePath` the absolute path to the file
* `$parent` the parent directory where the file is
* `$canonicalPath` the canonical path&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This way, the document is much easier to maintain. The documentation of the parameters is along with the code, and that way, it is harder to forget to update the documentation. Also, the name of the placeholder is taken directly from the source code. Even if the developer makes a typo naming the placeholder in the example above, the documentation will contain the name as it is in the code and the characters it has to be used.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Snippets can come from other sources, not only from file snippet fragments. The built-in macro &lt;code&gt;snip:xml&lt;/code&gt; reads a while XML file and assigns it to a macro name. This macro is similar to the built-in core macro &lt;code&gt;define&lt;/code&gt;. It also defines a user-defined macro. In this case, however, the macro is not a constant string with argument placeholders as those defined, calling the macro &lt;code&gt;define&lt;/code&gt;. In this case, the content is a whole parsed XML file, and the one argument the macro can and should have when invoked must be an XPath. As you can guess, the result of the macro call is the value in the XML found by the XPath.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;As an example, the module documentation &lt;code&gt;README.adoc.jam&lt;/code&gt; for &lt;code&gt;jamal-plantuml&lt;/code&gt; contains the following lines close to the start of the file:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;{%@snip:xml pom=pom.xml%}\
{%#define PLANTUML_VERSION={%pom /project/dependencies/dependency/artifactId[text()=&quot;plantuml&quot;]/following-sibling::version/text()%}%}\
{%#define VERSION={%pom /project/version/text()%}%}\&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It reads the &lt;code&gt;pom.xml&lt;/code&gt; file of the macro and defines the &lt;code&gt;PLANTUML_VERSION&lt;/code&gt; and &lt;code&gt;VERSION&lt;/code&gt; macros to hold the current version of the used PlantUml library and the version of the project, respectively. Later in the documentation, both &lt;code&gt;{%PLANTUML_VERSION%}&lt;/code&gt; and &lt;code&gt;{%VERSION%}&lt;/code&gt; can be used and will be replaced in the output with the up-to-date version.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;We have seen that snippet texts can be fetched from arbitrary source files and XML files. In addition to that, snippets can also be defined in &lt;code&gt;.properties&lt;/code&gt; files (even XML format properties file) and can also be defined as a macro. The snippet definition as a macro using the &lt;code&gt;snip:define&lt;/code&gt; built-in has a particular use that we will discuss later with the &lt;code&gt;snip:update&lt;/code&gt; macro.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;4-2-file-directory-class-method-consistency&quot;&gt;4.2. File, Directory, Class, Method &amp;#8658; Consistency&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The macros &lt;code&gt;file&lt;/code&gt;, &lt;code&gt;directory&lt;/code&gt;, &lt;code&gt;java:class&lt;/code&gt;, and &lt;code&gt;java:method&lt;/code&gt; are macros that can keep the code consistent with the system. These macros add barely any formatting to the output; therefore, their use needs discipline. They check that the argument file, directory, class, or method exists. If the entity does not exist, then the macro throws an exception. If the entity was renamed, moved, or deleted, the documentation has to be updated, or else it does not compile.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The use of the macros &lt;code&gt;file&lt;/code&gt; and &lt;code&gt;directory&lt;/code&gt; is straightforward. They check the existence of the file and directory specified as the argument. The name can either be absolute or relative to the input document.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Checking the existence of a class or method is not that straightforward. It needs a Java environment that has the class on the classpath. It is recommended to invoke Jamal from a unit test to convert the document from the input to output. This article is also written using Jamal as a preprocessor, and it is converted from a unit test of the module &lt;code&gt;jamal-snippet&lt;/code&gt; using the following code:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;private static void generateDoc(final String directory, final String fileName, final String ext) throws Exception {
    final var in = FileTools.getInput(directory + &quot;/&quot; + fileName + &quot;.&quot; + ext + &quot;.jam&quot;);
    final var processor = new Processor(&quot;{%&quot;, &quot;%}&quot;);
    final var result = processor.process(in);
    FileTools.writeFileContent(directory + &quot;/&quot; + fileName + &quot;.&quot; + ext, result);
}

@Test
void convertSnippetArticle() throws Exception {
    generateDoc(&quot;.&quot;, &quot;ARTICLE&quot;, &quot;wp&quot;);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;During the unit test&amp;#8217;s execution, the classes of the documented system are on the classpath or on the module path, and that way, these macros, &lt;code&gt;java:class&lt;/code&gt; and &lt;code&gt;java:method&lt;/code&gt; work.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;4-3-updating-the-input&quot;&gt;4.3. Updating the Input&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;code&gt;jamal-snippet&lt;/code&gt; library has a particular macro, &lt;code&gt;snip:update&lt;/code&gt;, which does something exceptional.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Built-in macro implementations get the part of the input, which is between the opening and closing string. It is the part of the input that they are supposed to work on. What they get is the input object containing not only the character but also a position coordinate. This coordinate contains the file name and the line/column position of the input in the file. Some macros use this coordinate to report the position of some error. Other macros, like &lt;code&gt;include&lt;/code&gt; or &lt;code&gt;import&lt;/code&gt;, use the file name to calculate the imported or included file path relative to the one that contains the macro.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The macro &lt;code&gt;snip:update&lt;/code&gt; uses the file name to access the file and modify it physically. The macro scans the file and looks for lines that look like&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;{%@snip id
   ...
%}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;When the lines with that pattern are found, then the lines between the first and last line, practically the lines denoted with &lt;code&gt;&amp;#8230;&amp;#8203;&lt;/code&gt; above, are replaced with the snippet&amp;#8217;s actual content. It will help the maintenance of the input document. When you write the document, it is easier to see the actual snippet and not only the reference to the snippet. It is also easier to debug the line killing, character replacement, and other snippet formatting transformations.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The macro &lt;code&gt;snip&lt;/code&gt; is not disturbed by these lines. The syntax of the &lt;code&gt;snip&lt;/code&gt; macro is like &lt;code&gt;snip id &amp;#8230;&amp;#8203; anything treated as a comment&amp;#8230;&amp;#8203;&lt;/code&gt; to allow this particular use case.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The invocation of the macro updating of the input should occur at the end of the document when all snippets are already defined. It is also essential to save the input to the version control before converting. The use of this possibility makes it possible to include into the document the formatted snippets. It is done, for example, in the documentation of the macro &lt;code&gt;directory&lt;/code&gt;. The sample presented before was a simplified one. Here you can see the real one making use of updates.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;{%#snip:define dirMacroFormatPlaceholdersFormatted=
{%#replaceLines{%#killLines{%@snip dirMacroFormatPlaceholders %}%}%}%}

{%@snip dirMacroFormatPlaceholdersFormatted
* `$name` gives the name of the directory as was specified on the macro
* `$absolutePath` gives the name of the directory as was specified on the macro
* `$parent` the parent directory
* `$canonicalPath` the canonical path
%}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This structure includes the snippet  &lt;code&gt;dirMacroFormatPlaceholders&lt;/code&gt; and converts enclosing it into macros &lt;code&gt;killLines&lt;/code&gt; and &lt;code&gt;replaceLines&lt;/code&gt;. The final formatted result, however, does not get directly into the output. It is assigned to a new snippet using the macro &lt;code&gt;snip:define&lt;/code&gt;. The name of the new snippet is &lt;code&gt;dirMacroFormatPlaceholdersFormatted&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;After this, when this new, already formatted snippet is defined, it is referenced using the &lt;code&gt;snip&lt;/code&gt; macro to be included in the output. When the macro &lt;code&gt;snip:update&lt;/code&gt; is used at the end of the file, this second use of the &lt;code&gt;snip&lt;/code&gt; macro is updated, and the formatted lines are inserted there, as you can see.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The first use of the macro &lt;code&gt;snip&lt;/code&gt; is not updated because there are extra characters before using the macro. Also, there are extra characters after the snippet identifier.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;4-4-creating-diagrams&quot;&gt;4.4. Creating Diagrams&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Using diagrams are very important in the documentation. As the saying goes, a picture is worth a thousand words, especially if your readers are non-native and do not even know a thousand words. An excellent tool to create diagrams is PlantUml. The source for the diagrams in this tool is a text that describes the UML diagram structurally. A simple sequence diagram can look like the following:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@startuml
Aladdin -&amp;gt; Jasmine : I love you
Jasmine -&amp;gt; Rajah : Aladdin loves me
Rajah --&amp;gt; Aladdin : wtf buddy?
@enduml&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;sample.svg&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Putting this text into the macro&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-text&quot; data-lang=&quot;text&quot;&gt;{%@plantuml sample.svg
Aladdin -&amp;gt; Jasmine : I love you
Jasmine -&amp;gt; Rajah : Aladdin loves me
Rajah --&amp;gt; Aladdin : wtf buddy?
%}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;will create the image, and it can then be referenced in the document to get&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;imageblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;img src=&quot;https://raw.githubusercontent.com/verhas/jamal/master/jamal-snippet/articleimages/sample.svg&quot; alt=&quot;sample&quot;&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;PlantUml is a widely used tool, and it has integration with many document processors. That way, it is integrated with Markdown and Asciidoc as well. Using Jamal as a preprocessor instead of the PlantUml direct integration has a few advantages, however.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You do not need to have the integration for PlantUml installed on the environment where the document rendering executes. You do not have it, for example, on GitHub or GitLab. Using Jamal, the PlantUml processing is done in your local environment, and after that, you just have a standard Markdown, Asciidoc, or whatever format you use. For example, this document uses WordPress markup, which does not have PlantUml integration, but it does not matter. The source named &lt;code&gt;ARTICLE.wp.jam&lt;/code&gt; is processed by Jamal generating &lt;code&gt;ARTICLE.wp&lt;/code&gt;, and it has everything it needs. Pictures are generated.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The Jamal preprocessing has other advantages. In this article, as an example, the text of the UML diagram appears three times. Once when I display for the example of how a UML digram is defined in PlantUml. The second time when I show how it is integrated using a Jamal macro. The third time it appears as an image.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The source input contains it only once before the first use. The user-defined macro, named &lt;code&gt;alilove&lt;/code&gt;, contains the actual UML, and the latter only references this macro to get the same text. If there is a need to update the structure, it must be done only in one place.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Another advantage is that the macros can access the running Java environment. It is already used when we check the existence and the naming of specific classes and methods. I also plan to extend the PlantUml integration with macros that can leverage the Java environment when we document our code. Running the conversion of the Jamal input during the unit tests reflection can get access to the classes. Using those, I plan to develop macros that need only the listing of the classes you want to be shown on a class diagram. The macro will discover all the relations between the classes and create a UML source to be converted to a diagram using PlantUml. Should your class structure change, the diagrams will also change automatically.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;5-summary-and-takeaway&quot;&gt;5. Summary and Takeaway&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You should approach technical documentation like programming. Document writers should maintain document source code and compile the document from the source code.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You should automate document content management as much as possible. Use automated tools to transclude information from the documented system. Use automated tools to check the consistency of the documentation. Document everything close to the system documented. Use automated tools to integrate your document source.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Give it a try and use Jamal.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;comments-imported-from-wordpress&quot;&gt;Comments imported from Wordpress&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;Peter Verhas&lt;/strong&gt; 2021-04-27 16:01:29&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Jamal is both A and B.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In my experience the advantage is not that it speeds up the editing process of the source, rather than it simplifies the maintenance afterwards and provides a better cohesion between the different document parts and between the documentation and the documented system. For example having a parameter in the Java code assigned to &lt;code&gt;static final&lt;/code&gt; field it is possible to get the value into the documentation using a macro. When the value changes you do not need to manually update the documentation. The macro will automatically fetch the value either using a pattern matching and sucking the value out of the source or using Java reflection.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Jamal is a text to text converter and it is not interested in formatting. You can have ASCIIDOC format document and work with Jamal. There are some processors that extend ASCIIDOC so you can use, for example plantUML. That is great and it is practically the same as Jamal plantUML support as far as the result is concerned: you will have plantUML pictures in your output and the plantUML source is inside your documentation and not in a separate file. But Jamal is not limited to ASCIIDOC. With a few macros you can tune it to include plantUML the same way into Markdown, or Wordpress formatted documents or whatnot. So long as long the output is text you can handle it with Jamal even of the output format does not natively support plantUML as an example.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;PlantUML is one example, but there can be other examples what you want to integrate your documentation with. What do you do if you want to fetch something from a databe and insert into your documentation? What if you have to get it from the network and you also need a transformation? The convention way is to write a separate program that collects the information, transforms it and then you can some way include into your document. The flow is the same with Jamal, but the processor supports you with external modules. You can read an XML file. You can read properties files. You can read Yaml files using macros and insert the data from those into your document. If that is not enough you can write small JShell, Ruby, ScriptBasic or Groovy scripts that can fetch, convert and present data for the document. If all fails you can even write macros in Java and you do not need to manage all the file nagdling, temporary data storage and so on. It is all managed by Jamal and you can select the approach that fits you the best.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Jamal also support JavaDoc implementing a Doclet and a Taglet. That way you can include into your JavaDoc document samples from your unit tests. After all unit tests are documentation. If that is not your desire you can also transform the unit test sample code using regular expression search and replace commands rendering a series of &quot;Assertions.assertEquals&amp;#8230;&amp;#8203;&quot; to HTML tables to display sample values. Or you can even write some simple scripts if regular expressions are not enough to transform the sample code to sample data.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Whenever you change the unit test extending the text data or modifying it the JavaDoc will automatically change.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;These are only the features that already exist and tested and documented. The roadmap includes many morepossibilities.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;ODI&lt;/strong&gt; 2021-02-26 18:50:52&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Sounds great to have new tool supporting documentation activities. It has a very much needs. In order to understand properly, I have been thinking a lot what kind of tool JAMAL really is. Two main categories came up to my mind:
A) content creator - to speed up editing the raw text content
B) content source assembler - to collect of different sources and build up the final publication result&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;However, for both categories there are several existent candidates, so the next thought was about new features JAMAL provides compared to them. For exmaple, some years ago, I came across &apos;Asciidoc FX&apos; (&lt;a href=&quot;https://asciidocfx.com/&quot; class=&quot;bare&quot;&gt;https://asciidocfx.com/&lt;/a&gt;) which is a very powerful asciidoc-based content editor with realtime WYSWYG capabilities. I liked it. It is very cool stuff. (Also has a function to include plantUML source.) As another example let me suggest to check the site builder &apos;Antora&apos; (&lt;a href=&quot;https://docs.antora.org/&quot; class=&quot;bare&quot;&gt;https://docs.antora.org/&lt;/a&gt;) which also relies on asciidoc source files. BTW, has JAMAL got an own defined language? Asciidoc (&lt;a href=&quot;https://docs.asciidoctor.org/asciidoc/latest/&quot; class=&quot;bare&quot;&gt;https://docs.asciidoctor.org/asciidoc/latest/&lt;/a&gt;) could be such a way. To sum up, I would say a toolset combining Asciidoc FX with Antora can support all the use cases you have described. And even if not, there is a chance to contribute with a new feature. :-)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Anyway, I totally agree with you that documentation should handle like a source code. There are a lot of commmon in procedures such version management, building/compiling (=publishing), visualizing track changes, &quot;running&quot; (=rendering interactive content). Unfortunately toolchains and practice are not so matured yet. Hope, some time or other DevOps CI/CD pipelines will always handle publishing of complete SW documentations as well.&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content><author><name></name></author><summary type="html">1. Introduction</summary></entry><entry><title type="html">Unit testing private methods</title><link href="https://javax0.github.io/2021/02/10/unit-testing-private-methods.html" rel="alternate" type="text/html" title="Unit testing private methods" /><published>2021-02-10T00:00:00+01:00</published><updated>2021-02-10T00:00:00+01:00</updated><id>https://javax0.github.io/2021/02/10/unit-testing-private-methods</id><content type="html" xml:base="https://javax0.github.io/2021/02/10/unit-testing-private-methods.html">&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;1-introduction&quot;&gt;1. Introduction&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In this article, I will contemplate the testing of private methods in unit tests. After that, I will propose a way or pattern to do it, if you must. Finally, I will show how you can generate this pattern automatically.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;And yes, I will also write a takeaway section to know what you have read.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;2-test-or-not-to-test-private-methods&quot;&gt;2. Test or not to Test Private Methods&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Unit testing is usually not black-box testing. It is debatable if it ought to be or not. Practice shows that it rarely is. When we equip the tested unit with different mocks, we play around with the implementation and not the defined functionality that a black-box test should only deal with.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;After setting up and injecting the mock objects, we invoke the tested methods, and these methods are usually public. In other words, the invocation of the tested system is more like a black-box test. You can say that the test setup is not a black-box test, but the actual test is.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The advantage of black-box testing is that it does not need to change if the tested module changes&apos; internal working. If the functionality changes, it is another story. It is easier to refactor, optimize, simplify, beautify your code if there are clean unit tests that do not depend on the implementation. If the unit tests depend on the implementation, then you cannot reliably refactor your code. As soon as you change the implementation, the test has to follow the change.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I do not particularly appreciate when the unit test cannot be black-box, but there are cases when it is unavoidable. An unusual and frequent case is when we want to test a private method. If you want to, or even God forgive, have to test a private method, it is a code smell. The method may be simple, and you can achieve the coverage of its functionality by invoking only the public API of the tested unit. You do not have to test the private method, and if you do not have to, you must not want.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Another possibility is that the private method is so complicated that it deserves its own test. In that case, the functionality deserves a separate utility class.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Still, there is a third possibility. After all the contemplating, we decide that the private method remains inside the unit, and we want to test it.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It is a small, insignificant problem that you cannot invoke from outside, and the test is inevitably out of the unit. Some developers remove the &lt;code&gt;private&lt;/code&gt; modifier changing the access level from private to &quot;test-private&quot;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;No kidding! After more than 500 technical interviews over the past ten years, I have heard many things. I regret that I did not start recording these. As I heard a few times, one of these lovely things: &quot;test private&quot; as a terminology instead of package-private. Two or three candidates out of the 500 said that the accessibility is test private when there is no access modifier in front of the class member. It means they said that the member can also be accessible from the unit tests. From other classes in the same package? Not so sure.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;What this story suggests is that many developers struggle to test private methods. I have also seen this in many other projects.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;I am not too fond of this approach because we weaken the access protection of a class member to ease testing.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;A different approach is when the tests use reflection to access the class members. There are two issues with this approach. One is the suboptimal performance. The other is the bloated code. The fact that the access to the class members via reflection is slower than the direct access is usually not significant. We are talking about tests. If the test execution needs significant time, then the tests are wrong, or the project is large or has some particular testing need. Even in these cases, the reason for the slow speed is usually not the reflective access.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The bloated code, on the other hand, hinders readability. It is also cumbersome to write every time things like&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;Field f = sut.getClass().getDeclaredField(&quot;counter&quot;);
f.setAccessible(true);
f.set(sut, z);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;when we want to set a private field, or&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;Method m = sut.getClass().getDeclaredMethod(&quot;increment&quot;);
m.setAccessible(true);
m.invoke(sut);&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;when we want to invoke a private method. The maintenance of such tests is also questionable. If the name of the method or field changes, the test has to follow. There is no significant risk of forgetting because the test will fail, but still, it is a manual editing functionality. Most of the IDEs support renaming. Whenever I rename a method or field, the IDE renames all the references to it. Not when the reference is part of a string.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;There is no real solution to this issue, except when you write code that does not need the testing of private methods and fields. Still, some approaches have advantages.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;3-doing-it-with-a-style&quot;&gt;3. Doing it with a Style&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;One approach is to declare a &lt;code&gt;private&lt;/code&gt; &lt;code&gt;static&lt;/code&gt; delegating inner class with the same name as the tested class. This class has to implement the same methods as the original tested class, and these implementations should delegate to the original methods. The class also has to implement setters and getters to all the fields.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If we instantiate this class instead of the original one, then we can invoke any method or set any field without reflective access in the test code. The inner class hides the reflective access.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The reason to name the class with the same simple name as the tested class is that the tests do not need to change this way. If a test has a code that instantiated the tested class calling &lt;code&gt;new Sut()&lt;/code&gt; and now we start to have an inner class named &lt;code&gt;Sut&lt;/code&gt;, then the constructor all of a sudden will refer to the inner class.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Let&amp;#8217;s see an example. The following class is a simple example that has one public method and a private one. The complexity of the methods barely reaches the level that would rectify extensive testing, but this makes it suitable for demonstration purposes.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;public class SystemUnderTest {

private int counter = 0;

public int count(int z) {
while (z &amp;gt; 0) {
z--;
increment();
}
return counter;
}

private void increment(){
counter++;
}

}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;This file, along with the other samples, can be found in full at &lt;a href=&quot;https://github.com/verhas/javageci/tree/1.6.1/javageci-jamal/src/test/java/javax0/geci/jamal/sample&quot; class=&quot;bare&quot;&gt;https://github.com/verhas/javageci/tree/1.6.1/javageci-jamal/src/test/java/javax0/geci/jamal/sample&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The test itself is also very simple:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Test
void testCounter() throws Exception {
final var sut = new SystemUnderTest();
sut.setCounter(0);
sut.increment();
Assertions.assertEquals(1, sut.getCounter());
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The only problem with this solution that the system under test does not contain the setter, and the method &lt;code&gt;increment()&lt;/code&gt; is private. The code, as it is now, does not compile. We have to provide an implementation of the delegating &lt;code&gt;static&lt;/code&gt; inner class named &lt;code&gt;SystemUnderTest&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The following code shows an implementation of this class, which I created manually.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;private static class SystemUnderTest {
private javax0.geci.jamal.sample.SystemUnderTest sut = new javax0.geci.jamal.sample.SystemUnderTest();

private void setCounter(int z) throws NoSuchFieldException, IllegalAccessException {
Field f = sut.getClass().getDeclaredField(&quot;counter&quot;);
f.setAccessible(true);
f.set(sut, z);
}

private int getCounter() throws NoSuchFieldException, IllegalAccessException {
Field f = sut.getClass().getDeclaredField(&quot;counter&quot;);
f.setAccessible(true);
return (int) f.get(sut);
}

private void increment() throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {
Method m = sut.getClass().getDeclaredMethod(&quot;increment&quot;);
m.setAccessible(true);
m.invoke(sut);
}

private int count(int z) {
return sut.count(z);
}
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It is already an achievement because we could separate the messy reflective access from the test code. The test, this way, is more readable. Since we cannot avoid the reflective code, it will not get better than this as per the readability. The other issue, maintainability, however, can still be improved.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;4-doing-it-automated&quot;&gt;4. Doing it Automated&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Creating the delegating inner class is relatively straightforward. It does not need much innovation. If you specify the task precisely, any cheaply hired junior could create the inner class. It is so simple that even a program can create it. It does not need the human brain.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If you tried to write a Java program from scratch that generates this code, it would be, well, not simple. Fortunately (ha ha ha), we have Java::Geci, and even more, we have the Jamal module. Jav::Geci is a code generation framework that you can use to generate Java code. The framework contains readily available code generators, but it is also open and pluggable, providing a clean API for new code generators. It does all the tasks needed for most of the code generators and lets the code generator program focus on its core business.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Code generation.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;For simpler applications, when the code generation is straightforward and does not need a lot of algorithm implementation, the module Jamal can be used. Jamal is a text-based templating language, which can be extended with Java classes implementing macros. The Java::Geci Jamal module includes a code generator that parses the source files and looks for code that has the following structure:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;/*!Jamal

TEMPLATE

*/

CODE HERE

//__END__&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;When it sees one, it evaluates the code that is written on the lines TEMPLATE using Jamal, and then it replaces the lines of CODE HERE with the result. It generates code, and if there was a generated code but is stale, it updates the code.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The code generation runs during the test execution time, which has advantages and disadvantages.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;One disadvantage is that the empty code or stale code should also compile. The compilation should not depend on the up-to-date-ness of the generated code. In practice, we usually (well, not usually, rather always) can cope with it.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The advantage is that the code generation can access the Java code structures via reflection. That way, for example, the code generators can get a list of all declared fields or methods and can generate some delegating methods for them.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The Jamal module contains Java classes implementing macros that can do that. The fact that you can express the generation of the unit test delegating inner class as Jamal macros shows the tool&amp;#8217;s power. On the other hand, I have to note that this task is somewhere at the edge of the tool&amp;#8217;s complexity. Nevertheless, I decided to use this task as a sample because generating setter and getters is boring. I also want to avoid lazy readers asking me why to have another setter/getter generator, as it happened at some conferences where I talked about Java::Geci. Setter and getter generator is not a good example, as it does not show you the advantage. You can do that with the IDE or using Lombok or some other tool. Perhaps after reading this article, you can try and implement the setter/getter generation using Jamal just for fun and to practice.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The previous code snippets were from the class &lt;code&gt;ManualTestSystemUnderTest&lt;/code&gt;. This class contains the manually created delegating inner class. I created this class for demonstration purposes. The other testing class, &lt;code&gt;GeneratedTestSystemUnderTest&lt;/code&gt; contains the generated sample code. We will look at the code in this file and how Java::Geci generates it automatically.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Before looking at the code, however, I have to make two notes:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;The example code uses a simplified version of the macros. These macros do not cover all the possible causes.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;On the other hand, the code includes all the macros in the source file. Professional code does not need to have these macros in the source. All they need is an import from a resource file and then the invocation of a single macro. Two lines. The macros generating the delegating inner class are defined in a resource file. It is written once, you do not need to write them all the time. I will show you at the end of this article how it is invoked.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Let&amp;#8217;s have a look at the class &lt;code&gt;GeneratedTestSystemUnderTest&lt;/code&gt;! This class contains the following Jamal template in a Java comment:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/*!jamal
{%@import res:geci.jim%}\
{%beginCode SystemUnderTest proxy generated%}
private static class SystemUnderTest {
private javax0.geci.jamal.sample.SystemUnderTest sut = new javax0.geci.jamal.sample.SystemUnderTest();
{%!#for ($name,$type,$args) in
({%#methods
{%class javax0.geci.jamal.sample.SystemUnderTest%}
{%selector private %}
{%format/$name|$type|$args%}
%}) =
{%@options skipForEmpty%}
private $type $name({%`@argList $args%}) throws Exception {
Method m = sut.getClass().getDeclaredMethod(&quot;$name&quot;{%`#classList ,$args%});
m.setAccessible(true);
m.invoke(sut{%`#callArgs ,$args%});
}
%}
{%!#for ($name,$type,$args) in
({%#methods
{%class javax0.geci.jamal.sample.SystemUnderTest%}
{%selector/ !private &amp;amp;amp; declaringClass -&amp;gt; ( ! canonicalName ~ /java.lang.Object/ )%}
{%format/$name|$type|$args%}
%}) =
{%@options skipForEmpty%}
private $type $name({%`@argList $args%}) {
{%`#ifNotVoid $type return %}sut.$name({%`#callArgs $args%});
}
%}
{%!#for ($name,$type) in
({%#fields
{%class javax0.geci.jamal.sample.SystemUnderTest%}
{%selector/ private %}
{%format/$name|$type%}
%}) =
{%@options skipForEmpty%}
private void {%setter=$name%}($type $name) throws Exception {
Field f = sut.getClass().getDeclaredField(&quot;$name&quot;);
f.setAccessible(true);
f.set(sut,$name);
}

private $type {%getter/$name/$type%}() throws Exception {
Field f = sut.getClass().getDeclaredField(&quot;$name&quot;);
f.setAccessible(true);
return ($type)f.get(sut);
}
%}
{%!#for ($name,$type) in
({%#fields
{%class javax0.geci.jamal.sample.SystemUnderTest%}
{%selector/ !private %}
{%format/$name|$type%}
%}) =
{%@options skipForEmpty%}
private void {%setter/$name%}($type $name) {
sut.$name = $name;
}

private $type {%getter/$name/$type%}() {
return sut.$name;
}
%}
}
{%endCode%}
*/&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;In this code the macro start string is &lt;code&gt;{%&lt;/code&gt; and the macro closing string is &lt;code&gt;%}&lt;/code&gt;. It is the default setting when Java::Geci starts Jamal to process a source file. This way, the macro enhanced template can freely contain standalone &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt; characters, which is very common in Java. Macros implemented as Java code use the &lt;code&gt;@&lt;/code&gt; or the &lt;code&gt;#&lt;/code&gt; character in front of the macro name. If there is no such character in front of the macro name, then the macro is user-defined from a &lt;code&gt;@define &amp;#8230;&amp;#8203;&lt;/code&gt; macro.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The text of the template contains three parts:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;the start of the code,&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;four loops, and&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;the end of the generated code in the template (this is just a closing &lt;code&gt;}&lt;/code&gt; character).&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The start of the template&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{%@import res:geci.jim%}\
{%beginCode SystemUnderTest proxy generated%}
private static class SystemUnderTest {
private javax0.geci.jamal.sample.SystemUnderTest sut = new javax0.geci.jamal.sample.SystemUnderTest();&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;imports the macro definitions from the resource file &lt;code&gt;geci.jim&lt;/code&gt;. The file itself is part of the library. If you have the dependency on the classpath when the code generator and the Jamal processor runs, you can import the definition from this resource file. The macro definitions in this file are simple Jamal macros defined as text. You can have a look at them at the URL&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/verhas/javageci/blob/1.6.1/javageci-jamal/src/main/resources/geci.jim&quot; class=&quot;bare&quot;&gt;https://github.com/verhas/javageci/blob/1.6.1/javageci-jamal/src/main/resources/geci.jim&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The next line uses the &lt;code&gt;beginCode&lt;/code&gt; user-defined macro, which is defined in &lt;code&gt;geci.jim&lt;/code&gt; as the following:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;{%@define beginCode(:x)=//&amp;lt;editor-fold desc=&quot;:x&quot;&amp;gt;%}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;When this macro is used it will result the start of an editor fold that helps to keep the generated code non-intrusive when the file is opened in the IDE. When this macro is evaluated, it will be&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;//&amp;lt;editor-fold desc=&quot;SystemUnderTest proxy generated&quot;&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The next two lines start the &lt;code&gt;private&lt;/code&gt; &lt;code&gt;static&lt;/code&gt; inner class. It is just plain text; there is no macro in it.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Now we get to the four loops that generate proxy codes for&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Delegating proxy methods for the &lt;code&gt;private&lt;/code&gt; methods of the tested class.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Delegating proxy methods for the non-private methods declared in the class or inherited, except those inherited from the &lt;code&gt;Object&lt;/code&gt; class.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Setter and getter methods for the &lt;code&gt;private&lt;/code&gt; fields of the tested class.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Setter and getter methods for the non-private fields of the tested class.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Since these are very similar, I will discuss here only the first in detail.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;{%!#for ($name,$type,$args) in
({%#methods
{%class javax0.geci.jamal.sample.SystemUnderTest%}
{%selector private %}
{%format/$name|$type|$args%}
%}) =
{%@options skipForEmpty%}
private $type $name({%`@argList $args%}) throws Exception {
Method m = sut.getClass().getDeclaredMethod(&quot;$name&quot;{%`#classList ,$args%});
m.setAccessible(true);
m.invoke(sut{%`#callArgs ,$args%});
}
%}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The loop is constructed using a &lt;code&gt;for&lt;/code&gt; macro, a Java-implemented, built-in macro of Jamal from the core package. This macro is always available for any Jamal processing. This macro iterates through a comma-separated list and repeats its contents for each list element replacing the loop variables with the actual values. There can be more than one loop variable. In such a case, like in our example, the actual value is split up along the &lt;code&gt;|&lt;/code&gt; characters. The comma used as a list separator, and the values separator &lt;code&gt;|&lt;/code&gt; can be redefined. In the above case, the &lt;code&gt;for&lt;/code&gt; loop uses three-loop variables, &lt;code&gt;$name&lt;/code&gt;, &lt;code&gt;$type&lt;/code&gt;, and`$args`. The start with a`$` sign has no significance. Any string can be used as a loop variable.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The list of values is between the &lt;code&gt;()&lt;/code&gt; characters after the &lt;code&gt;in&lt;/code&gt; keyword. This list is the result of the evaluation of the &lt;code&gt;methods&lt;/code&gt; built-in macro. This macro is implemented in Java and is part of the Java::Geci Jamal module. It is not a generally available Jamal macro, but when we run the code generation of Java::Geci, this JAR file is on the classpath, and thus this macro is available.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The &lt;code&gt;methods&lt;/code&gt; macro lists the methods of a class.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The class name is taken from the user-defined macro &lt;code&gt;$class&lt;/code&gt;, which can be defined using the user-defined macro &lt;code&gt;class&lt;/code&gt;. The listing also considers a selector expression that can be used to filter out some of the methods. It is also provided in a user-defined macro, and there is also a helper macro in &lt;code&gt;geci.jim&lt;/code&gt; to define it, named &lt;code&gt;selector&lt;/code&gt;. In the example above, the selector expression is &lt;code&gt;private&lt;/code&gt;, which will select only the private methods.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;When the list is collected, the macro &lt;code&gt;methods&lt;/code&gt; must convert it to a comma-separated list. To do that, it uses a formatting string that can contain placeholders. In our case, the placeholders are &lt;code&gt;$name&lt;/code&gt;, &lt;code&gt;$type&lt;/code&gt;, and &lt;code&gt;$args&lt;/code&gt;. Every element in the list for the &lt;code&gt;for&lt;/code&gt; loop will contain these three strings for the listed methods separated by two &lt;code&gt;|&lt;/code&gt; characters as indicated by the format string.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The part after the &lt;code&gt;=&lt;/code&gt; sign in the for loop is repeated for each method. It will declare a &lt;code&gt;private&lt;/code&gt; method that invokes the same method of the tested method. To do that, it uses the help of the Java::Geci Jamal module provided built-in macros &lt;code&gt;argList&lt;/code&gt;, &lt;code&gt;classList&lt;/code&gt;, and &lt;code&gt;callArgs&lt;/code&gt;. These help generating code that declares the arguments, lists the classes of the argument types or lists the arguments for the actual call.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Since this is just an article and not a full-blown documentation of Java::Geci and Jamal, I skip some details. For example, why the macro &lt;code&gt;for&lt;/code&gt; uses the &lt;code&gt;#&lt;/code&gt; character in front of it instead of &lt;code&gt;@&lt;/code&gt;, why there is a backtick character in front of the macros in the loop&amp;#8217;s body, and why the for loop uses a &lt;code&gt;!&lt;/code&gt; character. These details control the macro evaluation order. The list of the methods needs to be created before the &lt;code&gt;for&lt;/code&gt; loop starts because it requires the method list. On the other hand, the macros in the loop&amp;#8217;s body have to be evaluated after the loop generated the text for every listed method.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;Also, note that this implementation is for demonstration purposes only. It simplifies the problem and does not cover all the corner cases. For example, it will generate a setter for a &lt;code&gt;final&lt;/code&gt; field.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If you want to use this code generation, you can use the macro &lt;code&gt;proxy(KLASS)&lt;/code&gt; defined in the resource file &lt;code&gt;res:unittestproxy.jim&lt;/code&gt;.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;You can have a look at the class UnitTestWithGeneratedUnitTestProxy, which is a tad more complex than the sample and tests these macros. The start of the generated code is the following:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/*!jamal
{%@import res:unittestproxy.jim%}\

{%beginCode SystemUnderTest proxy generated%}
{%proxy javax0.geci.jamal.unittestproxy.TestSystemUnderTest%}
{%endCode%}
*/&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;It merely imports the &lt;code&gt;res:unittestproxy.jim&lt;/code&gt; file, which imports &lt;code&gt;geci.jim&lt;/code&gt; and then uses the macro &lt;code&gt;proxy&lt;/code&gt; to generate all the needed code covering all the corner cases.&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;If you want to use the code generator in your code, you have to do two things:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;olist upperalpha&quot;&gt;
&lt;ol class=&quot;upperalpha&quot;&gt;
&lt;li&gt;
&lt;p&gt;Include the dependency in your &lt;code&gt;pom.xml&lt;/code&gt; file:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-xml&quot; data-lang=&quot;xml&quot;&gt;&amp;lt;dependency&amp;gt;
&amp;lt;groupId&amp;gt;com.javax0.geci&amp;lt;/groupId&amp;gt;
&amp;lt;artifactId&amp;gt;javageci-jamal&amp;lt;/artifactId&amp;gt;
&amp;lt;version&amp;gt;1.6.1&amp;lt;/version&amp;gt;
&amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt;
&amp;lt;/dependency&amp;gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;olist upperalpha&quot;&gt;
&lt;ol class=&quot;upperalpha&quot;&gt;
&lt;li&gt;
&lt;p&gt;Create a small unit test that runs the code generator:&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/div&gt;
&lt;div class=&quot;listingblock&quot;&gt;
&lt;div class=&quot;content&quot;&gt;
&lt;pre class=&quot;highlight&quot;&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;@Test
@DisplayName(&quot;run the Jamal generator&quot;)
public void testRunJamalGenerator() throws Exception {
Geci geci = new Geci();
Assertions.assertFalse(
geci.register(new JamalGenerator())
.generate()
, geci.failed()
);
}&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;The generator runs during the unit test. During the test run, it has access to the structure of the Java code via reflection. The Jamal macros like &lt;code&gt;methods&lt;/code&gt;, &lt;code&gt;fields&lt;/code&gt; can query the different classes and provide the list of the methods and fields. The test fails if there was any new code generated. It only happens when the code generator runs the first time or when the tested system has changed. In this case, the test fails because the compiled code during the execution is not the final one. In such a case, start Maven again, and the second time the compilation already runs fine. Do not forget to commit the changed code. There is no risk of failing to update the generated code, like in IDE provided code generation that you have to invoke manually.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&quot;sect1&quot;&gt;
&lt;h2 id=&quot;5-takeaway&quot;&gt;5. Takeaway&lt;/h2&gt;
&lt;div class=&quot;sectionbody&quot;&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;What you should remember from this article:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;ulist&quot;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Try not to test private methods. If you feel the need, you did something wrong. Probably. Possibly not.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If you test private methods arrange the reflective code into a private static class that delegates the call to the original class. This will remove the implementation of the reflective access from the test and the test remains what it has to be: functionality test.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;If you are a lazy person, and as a good programmer you have to be, use a Java::Geci and Jamal to generate these inner classes for your tests.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Master Java::Geci and Jamal and use them to generate code for your other, specific needs.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&quot;sect2&quot;&gt;
&lt;h3 id=&quot;comments-imported-from-wordpress&quot;&gt;Comments imported from Wordpress&lt;/h3&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;&lt;strong&gt;Unit testing private methods | Java Code Geeks | World Best News&lt;/strong&gt; 2021-02-18 15:08:48&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&quot;quoteblock&quot;&gt;
&lt;blockquote&gt;
&lt;div class=&quot;paragraph&quot;&gt;
&lt;p&gt;[&amp;#8230;] Published on Java Code Geeks with permission by Peter Verhas, partner at our JCG program. See the original article here: Unit testing private methods [&amp;#8230;]&lt;/p&gt;
&lt;/div&gt;
&lt;/blockquote&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;</content><author><name></name></author><summary type="html">1. Introduction</summary></entry></feed>