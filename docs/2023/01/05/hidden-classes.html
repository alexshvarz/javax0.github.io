<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Hidden Classes in Java 15 | Java Deep, mostly Java</title>
<meta name="generator" content="Jekyll v4.3.3" />
<meta property="og:title" content="Hidden Classes in Java 15" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Article Management Technical Details Code https://github.com/javax0/javax0.github.io/tree/master/_projects/2023-01-05-hidden-classes Article source https://github.com/javax0/javax0.github.io/blob/master/_posts/2023-01-05-hidden-classes.adoc.jam 1. Introduction" />
<meta property="og:description" content="Article Management Technical Details Code https://github.com/javax0/javax0.github.io/tree/master/_projects/2023-01-05-hidden-classes Article source https://github.com/javax0/javax0.github.io/blob/master/_posts/2023-01-05-hidden-classes.adoc.jam 1. Introduction" />
<link rel="canonical" href="http://localhost:4000/2023/01/05/hidden-classes.html" />
<meta property="og:url" content="http://localhost:4000/2023/01/05/hidden-classes.html" />
<meta property="og:site_name" content="Java Deep, mostly Java" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2023-01-05T00:00:00+01:00" />
<meta name="twitter:card" content="summary" />
<meta property="twitter:title" content="Hidden Classes in Java 15" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-01-05T00:00:00+01:00","datePublished":"2023-01-05T00:00:00+01:00","description":"Article Management Technical Details Code https://github.com/javax0/javax0.github.io/tree/master/_projects/2023-01-05-hidden-classes Article source https://github.com/javax0/javax0.github.io/blob/master/_posts/2023-01-05-hidden-classes.adoc.jam 1. Introduction","headline":"Hidden Classes in Java 15","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2023/01/05/hidden-classes.html"},"url":"http://localhost:4000/2023/01/05/hidden-classes.html"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Java Deep, mostly Java" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Java Deep, mostly Java</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/about/">About</a><a class="page-link" href="/">Java Deep</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Hidden Classes in Java 15</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2023-01-05T00:00:00+01:00" itemprop="datePublished">Jan 5, 2023
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <details>
<summary class="title">Article Management Technical Details</summary>
<div class="content">
<div class="sidebarblock">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>Code <a href="https://github.com/javax0/javax0.github.io/tree/master/_projects/2023-01-05-hidden-classes">https://github.com/javax0/javax0.github.io/tree/master/_projects/2023-01-05-hidden-classes</a></p>
</li>
<li>
<p>Article source <a href="https://github.com/javax0/javax0.github.io/blob/master/_posts/2023-01-05-hidden-classes.adoc.jam">https://github.com/javax0/javax0.github.io/blob/master/_posts/2023-01-05-hidden-classes.adoc.jam</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
</details>
<div class="sect1">
<h2 id="1-introduction">1. Introduction</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Java can have anonymous classes from the very start.
(Well, actually, they came in version 1.1 only.)
However, anonymous classes were not anonymous.
You did not need to name them, but under the hood, they were named by the Java compiler.
If you are familiar with the command <code>javap</code>, you can "disassemble" a JAR file and see the name of the compiler generated for the anonymous classes.</p>
</div>
<div class="paragraph">
<p>Java 15 introduced hidden classes, which do not have a name.
Almost, as you will see.
It is not part of the language but part of the JDK.
There is no language element to create hidden classes, but JDK methods and classes come to the rescue.</p>
</div>
<div class="paragraph">
<p>In this article, we will discuss</p>
</div>
<div class="ulist">
<ul>
<li>
<p>what hidden classes are, and what is the reason to have them,</p>
</li>
<li>
<p>how you can use hidden classes,</p>
</li>
<li>
<p>how to load hidden classes using the JDK methods and, finally</p>
</li>
<li>
<p>how to easily create and load hidden classes using <a href="https://github.com/sourcebuddy/sourcebuddy">SourceBuddy</a>.</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>I created SourceBuddy, an Apache v2.0 licensed open-source program.
While creating the code, I learned a few things about hidden classes I wanted to share with you.
You may also look at this article as a SourceBuddy promotion, which is ok if you do that.
Nevertheless, I hope to successfully add extra value to this article so that this is not simply a promo.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="2-what-are-hidden-classes">2. What are hidden classes?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>There is an easy-to-read <a href="https://www.baeldung.com/java-hidden-classes">introductory article</a> about hidden classes on Baeldung.
If you are impatient and do not care about some intricate details, go there and read that article.
Baeldung articles are always short, focusing on the most important and correct.
They give a good starting point, which there would be no reason to repeat.</p>
</div>
<div class="paragraph">
<p>Hidden classes were proposed in the <a href="https://openjdk.org/jeps/371">JEP371</a>, and it reads:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>hidden &#8230;&#8203; classes that cannot be used directly by the bytecode of other classes</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>It is a bit short and may not be easy to understand.</p>
</div>
<div class="paragraph">
<p>A hidden class is loaded into the JVM.
When a class is in source code format or byte code, it cannot be "hidden".
This term can refer only to loaded classes.
Calling them secretly loaded classes could be more appropriate.</p>
</div>
<div class="paragraph">
<p>A class gets hidden when it is loaded in a particular way so that it remains secret in front of other code parts.
Remaining hidden does not mean that other codes cannot use this class.
They can so long as long they "know" about the secret.
The big difference is that this class is not "advertised" because you cannot find it using the name.</p>
</div>
<div class="paragraph">
<p>When you load a class the hidden way creating a hidden class, you will have a reference to this class.
Using the reflective methods, you can instantiate the class many times, and then you can invoke methods, set, and get fields.
If the class implements an interface or extends a class, you can cast the instance reference to the interface and class and invoke the methods without reflection.</p>
</div>
<div class="paragraph">
<p>The class is hidden for two reasons:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>it does not have a name other classes could reference, and</p>
</li>
<li>
<p>there is no reference from the class loader to the class.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When you call <code>getName()</code> or <code>getSimpleName()</code> on a variable referencing a hidden class, you will get some string.
These are names for messages for humans and are irrelevant for the other classes.
When a class refers to another class it needs the canonical name.
<code>getCanonicalName()</code> returns <code>null</code>.
The canonical name is the actual name of the class, which is non-existent in the case of hidden classes.</p>
</div>
<div class="paragraph">
<p>Since the class cannot be found through the class loader without the canonical name, there is no reason for the loader to keep a reference to the class.
Why would it keep a reference when it cannot give the class to anyone?
Keeping a reference would have only one side effect: preventing the GC from unloading the class so long as the class loader is alive.</p>
</div>
<div class="paragraph">
<p>Since there is no reference from the class loader, the GC can unload the class object as soon as it is out of use.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="3-what-is-the-use-of-hidden-classes">3. What is the use of hidden classes?</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The <a href="https://openjdk.org/jeps/371">JEP371</a> describes the reason for hidden classes.
It says</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Allow frameworks to define classes as non-discoverable implementation details of the framework so that they cannot be linked against other classes nor discovered through reflection.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Many frameworks use dynamically created classes.
They are proxy classes in most cases.
A proxy class implements an interface or extends another class, and when invoked, it calls an instance of the interface or the original class.
It usually does something extra as well, or else there would be no reason for the proxy class and instance.</p>
</div>
<div class="paragraph">
<p>An example is the Spring framework when your code requires injecting a request bean into a session bean.
(Or any other shorter lifecycle bean into a longer one.)
Several threads can serve different requests at the same time, all belonging to the same session.
All these threads will see the same session bean, but they magically will see their request beans.
The magic is a proxy object extending the request bean&#8217;s class.
When you call a method on the request bean, you invoke the proxy instance.
It checks the thread and the request it serves and forwards the call to the appropriate request bean.</p>
</div>
<div class="paragraph">
<p>Another example is JPA lazy loading.
You can have an SQL table where each row references the previous one.
When you try to load the last record, it will automatically load the previous one, which indeed will load the one before.
It will load the whole table.
It happens unless you annotate the field as lazy.
It means that the actual data from the database has to be loaded only when it is needed.</p>
</div>
<div class="paragraph">
<p>When you load the record, you get a proxy object.
This proxy object knows which record it refers to and will load the record from the database only when a method is called.</p>
</div>
<div class="paragraph">
<p>The same mechanism is used for Aspect Oriented Programming and many other cases.</p>
</div>
<div class="paragraph">
<p>You can create a proxy class using only the JDK reflection API so long as the target class implements the interface you want to proxy.
You can use the <a href="https://bytebuddy.net/">ByteBuddy</a> library if there is no such interface.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>The <a href="https://github.com/cglib/cglib">cglib</a> library is widely used and well-known in many frameworks, but it has been deprecated recently.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When you create such classes, you do not need any name for these classes.
You get the reference to the class and the reference to the instance.
The framework injects the reference to the field it has to, and then the code uses them as any object.
It does not need to know the name of the class.
All it needs to know is that it is an instance of the target class or interface.
However, some codes may discover the name.
These classes have some names that reflection can discover.
Some "clever" junior may discover it and play some neat trick that you may have later issues maintaining.
Would it be better if there was no name at all?
Probably yes, it would be cleaner.
Hence: hidden classes.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>The proxy classes may also cause issues when you implement the <code>equals(Object other)</code> method.
The usual implementation of the <a href="https://docs.oracle.com/en/java/javase/19/docs/api/java.base/java/lang/Object.html#equals(java.lang.Object)">equals</a> method compares the <code>other</code> object&#8217;s class to the actual class.
It will eventually be <code>false</code> when the other object is a proxy instance.
What the <code>equals()</code> method should check is the assignability whenever there is a possibility that the <code>other</code> object is a proxy.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>In addition to that, there is another reason to have hidden classes.
As soon as a class has a name, it is possible to discover it by the name.
The class loader has to keep the class alive to keep it discoverable.
The class loader has a reference to the loaded classes.
It means the garbage collector will not be able to collect the class, even when it is no longer in use.</p>
</div>
<div class="paragraph">
<p>If a class has no name, the class loader does not need to keep a reference to this class.
Class loaders do not keep references to hidden classes unless you explicitly instruct them to do so.
When all instances of a hidden class are collected, and there is no reference to the class, the garbage collector will recognize it as garbage.
The class loader will not keep the class in memory.</p>
</div>
<div class="paragraph">
<p>That way, the frameworks will not over-consume memory when a long-running code creates a lot of classes.
Better frameworks that collect unused classes do not need to create separate class loaders for these ephemeral classes.
There is no need to create a short-living, disposable class loader to make the class also disposable.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Support extending an access control nest with non-discoverable classes.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>It is the second bullet point in the list of goals in the <a href="https://openjdk.org/jeps/371">JEP371</a>.
JVM can load hidden classes in a way that they become a member of a nest.
What is a nest?</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>If you know what a nesting host is and are impatient, jump to the following quote.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Well, it is a long story, but since it is Christmas time, I am on holiday, and the press will not print this article on the paper wasting tree, here it goes.
(I wrote this article for weeks. It is still not published, and already next year, January.)</p>
</div>
<div class="paragraph">
<p>Once upon a time, Java version 1.0 did not have inner classes.
Now, you better stop reading it here if you ask me what inner classes are.
Then Java version 1.1 introduced inner classes but did not change the JVM structure.
The JVM did not know anything about inner classes.
The Java compiler created regular (almost) top-level classes from the inner classes.
It invented some funny names, like <code>A$B</code> when there was a class <code>B</code> inside <code>A</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
You can try to define an <code>A$B</code> top-level class in the same package where the class <code>A</code> containing the class <code>B</code> is.
<code>A$B</code> is a valid name.
You will see what the compiler does.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>There was some hacking with the visibility though.
An inner class has the same visibility as the top-level class.
Anything private inside one compilation unit (file) is visible.
Visibility, however, is also enforced by the JVM.
But the JVM sees two top-level classes.
The compiler generated bridge methods in the classes wherever needed to overcome this issue.
They are package level for the JVM, and when called, they pass on the call to the private method.</p>
</div>
<div class="paragraph">
<p>Then came Java 11 something like 25 years later and <a href="https://openjdk.org/jeps/181">introduced the nest control</a>.
Since Java 11, every class has a relation to another class or to itself, which is the nest host of the class.
Classes having the same nest host can see each other&#8217;s, private members.
The JVM does not need the bridge methods anymore.</p>
</div>
<div class="paragraph">
<p>When you load a class hidden, you can specify it to become a member of the same nest (having the same nest host) as the class that created the lookup object.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
We have not yet discussed what a lookup object is and how to load a class hidden.
It will come.
As for now: a lookup object is something that can load a byte array as a hidden class into the JVM memory.
When a lookup object is created from inside a method of a class, the lookup object will belong to that class.
When a class is loaded as hidden using the lookup object, it is possible to pass an option to make the new hidden class belong to the nest in which the code created the lookup object.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Without the hidden class functionality, I do not know any other possibility to load a class that will belong to an already existing nest.
If you know of any possibility, write it in a comment.</p>
</div>
<div class="paragraph">
<p>The following bullet point reads:</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Support aggressive unloading of non-discoverable classes, so that frameworks have the flexibility to define as many as they need.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>It is an important point.
When you create a class, it remains in the memory so long as the classloader is alive.
Classloaders keep references to all the classes they loaded.
These references say that some code may ask the classloader to return the loaded class object by the name.
The application logic may long forget the class; nobody will ever need it.
Still, the garbage collector cannot collect it because there is a reference in the class loader.
A solution is to create a new class loader for every new non-hidden dynamically created class, but that is overkill.</p>
</div>
<div class="paragraph">
<p>Classloaders loading hidden classes do not keep a reference to the hidden class by default.
As with the nesting host, it is possible to provide an option to differ.</p>
</div>
<div class="paragraph">
<p>I do not see any reason.
There is no name, not discoverable, but keep an extra reference so the GC cannot throw it away.
If you see any reasonable use case, again: comment.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Deprecate the non-standard API sun.misc.Unsafe::defineAnonymousClass, with the intent to deprecate it for removal in a future release.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Very well.
Yes.
Absolutely.
Separate articles and many of them.</p>
</div>
<div class="quoteblock">
<blockquote>
<div class="paragraph">
<p>Do not change the Java programming language in any way.</p>
</div>
</blockquote>
</div>
<div class="paragraph">
<p>Nice point. Sure.</p>
</div>
<div class="paragraph">
<p>With these, we discussed what hidden classes are.
You should have a firm understanding of their nature and why they are essential.
We also derailed a bit to nest hosting or host nesting, nesting hosting&#8230;&#8203; whatever.
I hope it was of some value.</p>
</div>
<div class="paragraph">
<p>In the following, I will discuss how we create hidden classes using the JDK API and then using <a href="https://github.com/sourcebuddy/sourcebuddy">SourceBuddy</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="4-creating-hidden-classes">4. Creating Hidden Classes</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Articles and tutorials showing how to load hidden classes use precompiled Java classes.
These are usually part of the running application.
The tutorial calculates the path to the <code>.class</code> file and reads the byte code.</p>
</div>
<div class="paragraph">
<p>Technically this is correct but does not demonstrate the basic need for hidden class loading: load dynamically created classes hidden.
These classes are not dynamically created and could be loaded the usual way.</p>
</div>
<div class="paragraph">
<p>In this article, we will create a class from text, Java source on the fly&#8201;&#8212;&#8201;during run-time&#8201;&#8212;&#8201;and then load the resulting byte code as a hidden class.</p>
</div>
<details>
<summary class="title">Code Sample Disclaimer</summary>
<div class="content">
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>The code samples are available on GitHub in the <a href="https://github.com/javax0/javax0.github.io/tree/master/_projects">project directory</a>.
Each article has a project directory named <code>YYYY-MM-DD-article-title</code> where the project code files are.</p>
</div>
<div class="paragraph">
<p>For this article it is <code>2023-01-05-hidden-classes</code>.</p>
</div>
<div class="paragraph">
<p>The samples are automatically copied from the project directory to the article using Jamal.
No manual copy, no outdated stale samples.</p>
</div>
</div>
</div>
</div>
</details>
<div class="paragraph">
<p>The sample project for this article contains only unit test files.
The class is <code>TestHiddenClassLoader</code>.
We have the source code for the hidden class stored in a field variable.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"> 1.     private static final String CODE1 = """
 2.             package com.javax0.blog.hiddenclasses;
 3.
 4.             public class MySpecialClass implements TestHiddenClassLoader.Hello {
 5.
 6.                 @Override
 7.                 public void hello() {
 8.                     System.out.println("Hello, from the hidden class.");
 9.                 }
10.             }
11.             """;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The interface is also inside the same class.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">1.     interface Hello {
2.         void hello();
3.     }
4.</code></pre>
</div>
</div>
<div class="paragraph">
<p>The following code is from one of the unit tests:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">1.         final var byteCode = Compiler.java().from(CODE1).compile().get();
2.         final var lookup = MethodHandles.lookup();
3.         final var classLookup = lookup.defineHiddenClass(byteCode, true);
4.         final var helloClass = (Class&lt;Hello&gt;) classLookup.lookupClass();
5.
6.         final var hello = helloClass.getConstructor().newInstance();
7.         hello.hello();</code></pre>
</div>
</div>
<div class="paragraph">
<p>We use the <a href="https://github.com/sourcebuddy/sourcebuddy">SourceBuddy</a> library in this code to compile the Java source to byte code.
The first line of the sample does that.
We use <a href="https://github.com/sourcebuddy/sourcebuddy">SourceBuddy</a> version 2.1.0.</p>
</div>
<div class="paragraph">
<p>We need a lookup object to load the compiled byte code as a hidden class.
This object is created on the second line.
The lookup object is used on the third and fourth lines to load the class hidden.
Line 3 defines the class loading it into the JVM.
The second argument, <code>true</code>, initializes the class.
That is when the <code>static{}</code> blocks execute.
The last line invokes the interface-defined method <code>hello()</code>.</p>
</div>
<div class="paragraph">
<p>Now the local variable <code>hello</code> is an instance of an object, a hidden class.
What are a hidden class&#8217;s name, simple name, and canonical name?
Let&#8217;s print it out.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">1.         System.out.println("1. " + hello.getClass());
2.         System.out.println("2. " + hello.getClass().getClassLoader());
3.         System.out.println("3. " + this.getClass().getClassLoader());
4.         System.out.println("4. " + hello.getClass().getSimpleName());
5.         System.out.println("5. " + hello.getClass().getName());
6.         System.out.println("6. " + hello.getClass().getCanonicalName());
7.         System.out.println("7. " + lookup.getClass());
8.         System.out.println("8. " + lookup.getClass().getClassLoader());</code></pre>
</div>
</div>
<details>
<summary class="title">Output Disclaimer</summary>
<div class="content">
<div class="sidebarblock">
<div class="content">
The output in the unit tests is redirected calling <code>System.setOut()</code>.
The output is collected to a file and then this file is included calling <code>include [verbatim]</code> Jamal macro into the article.
</div>
</div>
</div>
</details>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">Hello, from the hidden class.
1. class com.javax0.blog.hiddenclasses.MySpecialClass/0x00000008011b0c00
2. jdk.internal.loader.ClassLoaders$AppClassLoader@5b37e0d2
3. jdk.internal.loader.ClassLoaders$AppClassLoader@5b37e0d2
4. MySpecialClass/0x00000008011b0c00
5. com.javax0.blog.hiddenclasses.MySpecialClass/0x00000008011b0c00
6. null
7. class java.lang.invoke.MethodHandles$Lookup
8. null</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can see the output from calling <code>hello()</code> and then the name as printed from the implicit <code>toString()</code> from the class object, the class loader that loaded the hidden class, the simple name, the name, and in the last line the canonical name.
This last one is interesting as it is <code>null</code>, showing no class name.
It is hidden.</p>
</div>
<div class="paragraph">
<p>The class, although hidden, has a reference to the class loader that loaded it.
It is needed when there is anything to resolve during the execution of the code.
The difference is that the class loader does not have a reference to the class.
One direction from the class to the loader exists, but the other direction from the loader to the class does not.</p>
</div>
<div class="paragraph">
<p>The class loader is the same as the one that loaded the class calling <code>MethodHandles.lookup()</code>.
You can see that since we printed out the class loader of the <code>this</code> object in the test.</p>
</div>
<div class="paragraph">
<p>Finally, we also print out the class of the lookup object and the class loader.
The latter is <code>null</code>, which means the bootstrap class loader loaded it. (For more information on class loaders, I can recommend reading the article <a href="https://www.baeldung.com/java-classloaders">class loaders</a> from the Baeldung blog.)</p>
</div>
<div class="paragraph">
<p>You should also note that the interface <code>hello</code> is package private.
It is still visible for the dynamically created code because it is in the same package and module.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>Starting with Java 9, there is a module system in Java.
Many developers I meet say they are not interested in JPMS; they do not need to use it.</p>
</div>
<div class="paragraph">
<p>The fact is that you DO use it, whether you want it or not.
It is the same as concurrent programming.
Java is concurrent; at least there are three threads in a JVM, so your code runs in a concurrent environment, whether you want it or not.
You may not have trouble understanding the details for a long time.
However, when you start digging deeper and creating code that uses some "tricks" or does something special, you almost certainly face some weird errors.
You must know and understand the underlying theory to understand the errors, handle them, mitigate the cause, and fix the bug.</p>
</div>
<div class="paragraph">
<p>Loading hidden classes dynamically created is precisely such a trick.
You should learn Java Modules.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>When the hidden class is loaded, it is in the same package as the one where the interface is defined.
It is not enough, however, as we will see an example in the next section.
It is also a requirement that the same class loader loads the interface and the hidden class.
That way, the interface, and the hidden class are in the same module, in this case, the same unnamed module.
The different class loaders load classes into different modules; thus, when you load a class using a different class loader, it may not see the package fields, methods, interfaces, etc., even if they are in the same package.</p>
</div>
<div class="paragraph">
<p>It is not the only requirement that the lookup object is from the same module.
It is also a requirement that it is from the same package as the class to be loaded.
We must stop here to clarify things, to be painfully precise, because it is easy to confuse things at this point.</p>
</div>
<div class="paragraph">
<p>The lookup object is an instance of a class in the <code>java.lang.invoke</code> package.
The class loader loaded this class is <code>null</code> as shown in the output.
It means the bootstrap class loader.
The bootstrap class loader is implemented in C/C++ and not in Java.
No corresponding Java object represents this class loader; thus, there cannot be a reference to it.
It is solved by returning <code>null</code> from <code>getClassloader()</code>.
There is a module, package, and class that "belongs" to the lookup object.
The code&#8217;s module, package, and class were called the <code>MethodHandles.lookup()</code> method.</p>
</div>
<div class="paragraph">
<p>You cannot create a hidden class from one package for another.
If you try that, like in the following sample code:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">1.         try {
2.             final var byteCode = Compiler.java()
3.                     .from("package B; class A{}").compile().get();
4.             MethodHandles.lookup().defineHiddenClass(byteCode, true);
5.         } catch (Throwable t) {
6.             System.out.println(t);
7.         }</code></pre>
</div>
</div>
<div class="paragraph">
<p>still from the test class <code>com.javax0.blog.hiddenclasses.TestHiddenClassLoader</code>.
The class to be loaded is NOT in the same package as the caller for <code>MethodHandles.lookup()</code>.
It will result in the printout:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">java.lang.IllegalArgumentException: B.A not in same package as lookup class</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="5-creating-hidden-classes-the-easy-way">5. Creating hidden classes the easy way</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In the previous section, we created a new class dynamically and loaded the new class hidden.
The loading was done using lookup objects we acquired from the <code>MethodHandles</code> class.
In this section, we will see how we can do the same by calling the fluent API of <a href="https://github.com/sourcebuddy/sourcebuddy">SourceBuddy</a>.</p>
</div>
<div class="paragraph">
<p>The code creating a class saying hello is the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">1.         final var hello = Compiler.java()
2.                 .from(CODE1.replaceAll("\\.Hello", ".PublicHello")).hidden()
3.                 .compile().load().newInstance(PublicHello.class);
4.         hello.hello();</code></pre>
</div>
</div>
<div class="paragraph">
<p>In this code, we replaced the interface from <code>Hello</code> to <code>PublicHello</code>, which you may guess:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">1.     public interface PublicHello {
2.         void hello();
3.     }</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is essentially the same as the previous interface but is <code>public</code>.
The process is much more straightforward than before.
We specify the source code; we declare that it is a hidden class calling <code>hidden()</code>, and we compile, load, and ask for an instance cast to <code>PublicHello</code>.</p>
</div>
<div class="paragraph">
<p>If we want to use the package-private interface, like (not replacing <code>Hello</code> to <code>PublicHello</code>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">1.         Assertions.assertThrows(IllegalAccessError.class, () -&gt;
2.                 Compiler.java().from(CODE1).hidden().compile().load().newInstance(PublicHello.class));</code></pre>
</div>
</div>
<div class="paragraph">
<p>we will get an error.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-text" data-lang="text">java.lang.IllegalAccessError: class com.javax0.blog.hiddenclasses.MySpecialClass/0x00000008011b1c00 cannot access its superinterface com.javax0.blog.hiddenclasses.TestHiddenClassLoader$Hello (com.javax0.blog.hiddenclasses.MySpecialClass/0x00000008011b1c00 is in unnamed module of loader com.javax0.sourcebuddy.ByteClassLoader @4e5ed836; com.javax0.blog.hiddenclasses.TestHiddenClassLoader$Hello is in unnamed module of loader 'app')</code></pre>
</div>
</div>
<div class="paragraph">
<p>The reason is explained clearly in the error message.
The interface and the class implementing it are in two different modules.
Both are unnamed modules, but they are not the same.
In Java, starting with Java 9, there are modules, and when the application does not use modules, it essentially creates pseudo modules putting the classes there.
The JDK classes are still in modules, like <code>java.base</code>.</p>
</div>
<div class="paragraph">
<p>The hidden class creation, as created above, uses a separate class loader to load the dynamically written Java class.
The separate class loader loads classes to its module.
Code in different modules cannot see classes from other modules unless they are public.</p>
</div>
<div class="paragraph">
<p>Although <a href="https://github.com/sourcebuddy/sourcebuddy">SourceBuddy</a> does a little trick to load a class hidden, it cannot overcome this restriction.</p>
</div>
<div class="paragraph">
<p>Loading a hidden class needs a lookup object.
The application usually provides this object.
The calls above do not specify any lookup object, but <a href="https://github.com/sourcebuddy/sourcebuddy">SourceBuddy</a> still needs one.
To have one, it creates one.
The lookup object remembers the class called <code>MethodHandles.lookup()</code> to create one.
When loading a class hidden, it is required that the lookup object "belongs" to the class&#8217;s package.
The lookup object was created, calling for it from a class, which is <strong>in</strong> that package.
The lookup object will "belong" to that class and hence to the class&#8217;s package.</p>
</div>
<div class="paragraph">
<p>To have a lookup object that comes from a class from a specific package we need a class in that package that can give us one.
If there is none in the code, we must create one dynamically.
<a href="https://github.com/sourcebuddy/sourcebuddy">SourceBuddy</a> does that exactly.
It creates the Java source code for the class, compiles it and loads it, instantiates it, and calls the  <code>Supplier&lt;MethodHandles.Lookup&gt;</code> defined <code>get()</code> method the class implements.</p>
</div>
<div class="paragraph">
<p>It is a kind of trick that seems to violate the access control built-in to Java.
We seem to get a new hidden class in a package that was not prepared for it.
A package is protected from external access in Java (trivial).
Only public and protected members and classes can be used from outside the package.
The package can be accessed using reflection from the outside, but only in the same module, or the module has to be opened explicitly.
Similarly, an object loaded using a lookup object should be in the same package and access the package&#8217;s internal members and whatnot if a class in the package provided that lookup.</p>
</div>
<div class="paragraph">
<p>As we can see from the error message, it only seems to be the package.
In reality, the new hidden class is in a package with the same name but in a different module.</p>
</div>
<div class="paragraph">
<p>If you want to have a hidden class in the same package and not only a package with the same name, you need a lookup object from that package.</p>
</div>
<div class="paragraph">
<p>In our example, it is simple.
Our <code>Hello</code> interface is in the same package as the test code so that we can create the lookup object ourselves:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">1.         final var hi = Compiler.java().from(CODE1).hidden(MethodHandles.lookup()).compile()
2.                 .load().newInstance(Hello.class);
3.         hi.hello();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Access to a lookup object may be a bit more complex in real-life examples.
When the code calling <a href="https://github.com/sourcebuddy/sourcebuddy">SourceBuddy</a> is in a different package than the code generated, the lookup object creation cannot be in the <a href="https://github.com/sourcebuddy/sourcebuddy">SourceBuddy</a> calling code.</p>
</div>
<div class="paragraph">
<p>In the following example, we will see how that will be done.</p>
</div>
<div class="paragraph">
<p>We have a class <code>OuterClass</code> in the package <code>com.javax0.blog.hiddenclasses.otherpackage</code>.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"> 1. package com.javax0.blog.hiddenclasses.otherpackage;
 2.
 3. import java.lang.invoke.MethodHandles;
 4.
 5. public class OuterClass {
 6.
14.     public static MethodHandles.Lookup lookup() {
15.         return MethodHandles.lookup();
16.     }
17. }</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
Some lines are skipped from the class. We will use those later.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This class has a method, <code>lookup()</code>.
It creates a lookup object and returns it.
We will have a proper lookup object if we call this method from our code.
Note that this class is in a different package and not the same as our test code.
Our test code is in <code>com.javax0.blog.hiddenclasses</code>, and <code>OuterClass</code> is a package deeper.
Essentially in a different package.</p>
</div>
<div class="paragraph">
<p>We also have another class for the demonstration.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java">1. package com.javax0.blog.hiddenclasses.otherpackage;
2.
3. class MyPackagePrivateClass {
4.
5.     void sayHello(){
6.         System.out.println("Hello from package private.");
7.     }
8.
9. }</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is a package-private class with a package-private method in it.
If we dynamically create a hidden class, as in the following example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"> 1.         final var hidden = Compiler.java().from("""
 2.                 package com.javax0.blog.hiddenclasses.otherpackage;
 3.
 4.                 public class AnyName_ItWillBeDropped_Anyway {
 5.                     public void hi(){
 6.                         new MyPackagePrivateClass().sayHello();
 7.                     }
 8.                 }""").hidden(OuterClass.lookup()).compile().load().newInstance();
 9.         final var hi = hidden.getClass().getDeclaredMethod("hi");
10.         hi.invoke(hidden);</code></pre>
</div>
</div>
<div class="paragraph">
<p>It will work.</p>
</div>
<div class="paragraph">
<p>There is one topic that we have not touched on.
It is how to create a nestmate.</p>
</div>
<div class="paragraph">
<p>When you have a binary class file, you can load it as a nestmate to a class that provides a lookup object.
The JVM does not care how that class was created.
When we compile Java sources, we only have one possibility.
The class has to be an inner class.</p>
</div>
<div class="paragraph">
<p>When you use <a href="https://github.com/sourcebuddy/sourcebuddy">SourceBuddy</a>, you have to provide your source code as an inner class to the one you want the hidden to be nest mate with.
The source code and the class was already provided when you compiled your code.
It is not possible to insert into THAT source code any new inner class.
We have to fool the compiler.</p>
</div>
<div class="paragraph">
<p>We provide a class having the same name as the one we want to insert our inner class later.
When the compilation is done, we have the outer class and the inner class as well.
We tell the class loading to forget the outer and only to load the inner one, hidden.</p>
</div>
<div class="paragraph">
<p>It is what we will do.
This time we display here the whole outer class that we use for demonstration including the skipped lines.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"> 1. package com.javax0.blog.hiddenclasses.otherpackage;
 2.
 3. import java.lang.invoke.MethodHandles;
 4.
 5. public class OuterClass {
 6.
 7.     // skip lines
 8.     private int z = 55;
 9.
10.     public int getZ() {
11.         return z;
12.     }
13.     // end skip
14.     public static MethodHandles.Lookup lookup() {
15.         return MethodHandles.lookup();
16.     }
17. }</code></pre>
</div>
</div>
<div class="paragraph">
<p>As you will see, it has a private field and a getter to test the changed value effectively.
It also has the before-mentioned <code>lookup()</code> method.
The code dynamically creating an inner class is the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"> 1.         final var inner = Compiler.java().from("""
 2.                         package com.javax0.blog.hiddenclasses.otherpackage;
 3.
 4.                         public class OuterClass
 5.                                                 {
 6.                             private int z;
 7.
 8.                             public static class StaticInner {
 9.                                public OuterClass a(){
10.                                  final var outer = new OuterClass();
11.                                  outer.z++;
12.                                  return outer;
13.                                }
14.                             }
15.
16.                         }""").nest(MethodHandles.Lookup.ClassOption.NESTMATE).compile().load()
17.                 .newInstance("StaticInner");
18.         final var m = inner.getClass().getDeclaredMethod("a");
19.         final var outer = (OuterClass)m.invoke(inner);
20.         Assertions.assertEquals(56, outer.getZ());</code></pre>
</div>
</div>
<div class="paragraph">
<p>There is an <code>OuterClass</code> in the source, but it is only to help the compilation and to tell <a href="https://github.com/sourcebuddy/sourcebuddy">SourceBuddy</a> the name of the nesting host.
When we call the method <code>nest()</code> with the option <code>NESTMATE</code>, it knows that the class <code>OuterClass</code> is the nesting host.
It also marks the class not to be loaded by the class loader ever.
The inner class compiles to a different byte code, and when it is loaded, it becomes a nestmate of <code>OuterClass</code>.</p>
</div>
<div class="paragraph">
<p>If you pay attention to the intricate details of Java access control discussed in this article, you will notice that we do not provide a lookup object.
And the example above still works.
How is it possible?
There is no magic.
When you call <code>nest()</code>, <a href="https://github.com/sourcebuddy/sourcebuddy">SourceBuddy</a> looks for the already loaded version of <code>OuterClass</code> and fetches the lookup object using reflection.
To do that the outer class has to have a static field or method of type <code>MethodHandles.Lookup</code>.
<code>OuterClass</code> has a method, so <a href="https://github.com/sourcebuddy/sourcebuddy">SourceBuddy</a> calls this method to get the lookup object.</p>
</div>
<div class="paragraph">
<p>The example above creates a static inner class.
You can create the same way a non-static inner class as well.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<div class="title">Note</div>
</td>
<td class="content">
<div class="paragraph">
<p>The difference between static and non-static inner classes in Java is that non-static inner class instances have a reference to an outer class instance.
Static inner classes do not.
It is where the name comes from.
Static inner class instances belong to the class.
Non-static belongs to an instance of the outer class.</p>
</div>
<div class="paragraph">
<p>To get the reference to the outer class instance, the inner class&#8217;s constructor is modified.
When you specify a constructor for an inner class, the compiled adds an extra parameter in front of the other parameters specified in the Java source code.
This extra first parameter is the reference to the outer class instance.
This reference is stored in a field not available at the source level but used by the code to access the fields and methods of the outer instance.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The creation of a non-static inner class looks very much the same as the creation of a static inner class:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-java" data-lang="java"> 1.         final var outer = new OuterClass();
 2.         final var inner = Compiler.java().from("""
 3.                         package com.javax0.blog.hiddenclasses.otherpackage;
 4.
 5.                         public class OuterClass {
 6.                             private int z;
 7.
 8.                             public class Inner {
 9.                                public void a(){
10.                                  z++;
11.                                }
12.                             }
13.
14.                         }""").nest(MethodHandles.Lookup.ClassOption.NESTMATE).compile().load()
15.                 .newInstance("Inner", classes(OuterClass.class), args(outer));
16.         final var m = inner.getClass().getDeclaredMethod("a");
17.         m.invoke(inner);
18.         Assertions.assertEquals(56, outer.getZ());</code></pre>
</div>
</div>
<div class="paragraph">
<p>We need an instance of the outer class to instantiate the inner class.
It is the variable <code>outer</code>.
We must pass this variable to the constructor through the <code>newInstance()</code> API of <a href="https://github.com/sourcebuddy/sourcebuddy">SourceBuddy</a>.
This method call has a version that accepts a <code>Class[]</code> and an <code>Object[]</code> array specifying the constructor argument types and values.
In the case of an inner class, it is the outer class and an instance.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="6-summary">6. Summary</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This article discussed some details of the hidden classes introduced in Java 15.
We went a little deeper than the usual introductory articles.
Now you understand how hidden classes work and how to use them in your projects.</p>
</div>
<details>
<summary class="title">How to Comment</summary>
<div class="content">
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>Use the Disqus commenting possibility to comment.
If you find any incorrectness in the article, you are welcome to mention it.
You can also access the source code of the article on github at</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/javax0/javax0.github.io/blob/master/_posts/2023-01-05-hidden-classes.adoc.jam"><code>https://github.com/javax0/javax0.github.io/blob/master/_posts/2023-01-05-hidden-classes.adoc.jam</code></a></p>
</div>
<div class="paragraph">
<p>You are welcome to create a <a href="https://github.com/javax0/javax0.github.io/issues/new">ticket</a>, create a  <a href="https://github.com/javax0/javax0.github.io/fork">fork</a>, suggest modification via pull requests.
Note that this repository also contains the demonstration sample source code.</p>
</div>
<div class="paragraph">
<p>For other aspects of commenting read the <a href="https://javax0.github.io/about/">ABOUT</a> page of this blog.</p>
</div>
</div>
</div>
</div>
</details>
</div>
</div>


<!-- Disqus comments section goes here (if comments are enabled) -->

<hr/>
<h1>Comments</h1>
<p>Please leave your comments using Disqus, or just press one of the happy faces.
If for any reason you do not want to leave a comment here, <a href="https://github.com/javax0/javax0.github.io/issues">you can still create a Github ticket</a>.</p>
<div class="comments">
    <div id="disqus_thread"></div>

    <script type="text/javascript">

        /* * * STOP! * * */
        /* You shouldn't need to edit ANYTHING below to get this working! */
        /* Instead, edit the key `disqus.shortname` in _config.yml */

        var disqus_config = function (){
            this.page.url = 'http://localhost:4000/2023/01/05/hidden-classes.html';
            this.page.identifier = '/2023/01/05/hidden-classes.html';
        };

        (function() {
            var d = document, s = d.createElement('script');
            s.type = 'text/javascript'; s.async = true;
            s.src = 'https://javax0.disqus.com/embed.js';
            s.setAttribute('data-timestamp', +new Date());
            (d.head || d.body).appendChild(s);
        })();

    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>




  </div><a class="u-url" href="/2023/01/05/hidden-classes.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Java Deep, mostly Java</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Java Deep, mostly Java</li><li><a class="u-email" href="mailto:peter@verhas.com">peter@verhas.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/verhas"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">verhas</span></a></li><li><a href="https://www.twitter.com/verhas"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">verhas</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>javax0 is a technical Java oriented blog. Whenever I find something interesting, in the mood and feel the power to publish it, you will get it here. Publications are usually released on Wednesday 15:00am GMT. Earlier posts of the blog were published on Javax0 Wordpress Site at https://javax0.wordpress.com</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
