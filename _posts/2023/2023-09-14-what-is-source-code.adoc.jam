---
{%@define title=What is source code?%}
title: {%title%}
layout: posta
comments: on
---
{%@import javax0.jim%}
{%@comment

=========================================================================================
%}
{%@sep 〔〕%}
= 〔title〕

〔section Introduction〕

This article is about the definition of source code.
Usually, this is straightforward, and there is no need for contemplating on this topic.
Everybody knows what source code is.
In some special cases, however, we may get confused and knowing what we are really doing may help avoid mistake.
This is not a philosophical article.
There is merit in knowing and understanding some of the rules we follow and to know when we deliberately break these rules and face the consequences.

〔section The story behind the issue〕

In a project, we started to use GitLab and the CI/CD features of it.
The description of the tasks should be given in a YAML file ``.gitlab-ci.yml``.
We realized that the task descriptions, managing versions are redundant.
They may appear elsewhere in the project, and we have to keep them in sync.

I suggested to the team that we should use a single source of truth.
To do that, we could use a Kotlin DSL file and use Gradle build to generate the YAML file.

This solution would work, but it is not a clean solution.
What is the problem with it?

The problem is that it generates a file that describes the process, which indeed includes the generation of this description file.
It is like a snake biting its tail.

In practice, it works.
You can run the build on the developer machine, generate the YAML file, and then commit it to the repository along with the other source files.
In this case, however, there is a mandatory part of the build running on the developer machine.
It is against the idea of CI/CD that the build in its entirety should be run on the CI/CD server.

The compromise I also applied in the Java::Geci project is that the

* the tool is treated as a "personal productivity tool", like an editor running on the developer machine, and

* the same tool is used as a "test tool" that is run on the CI/CD server.

When running on the developer machine as a standalone tool or as part of the build process, it will generate the CI/CD YAML.
When running on the CI/CD server, it will check that the YAML file is up-to-date.
If the build life cycle contains the regeneration of the CI/CD YAML during the test phase, the standard test failure signals can be used to fail and stop a build.
On the developer machine, the build can interactively be restarted.
On the CI/CD server, the failure is a hard failure.
This way the generated code is partially treated as source code.

Is this a clean solution?
No.
It is a workaround making the build process more complicated.
Is it worth doing it?
One should decide on a case-by-case basis.

What would be the clean solution?
I will answer that question at the end of this article in the takeaway section, but to get there and to understand the reasoning behind it, we have to go through some almost philosophical contemplation.

What we have to answer is the following:

〔section What is source code?〕

The problem with this question is that it is too simple.
We all know what source code is.
We work with source code every day.
That is the text file we edit, send to the compiler, store in version control databases, and so on.

Even ChatGPT will give an answer to this question.
Not a good one, though, but a partially correct one.

I do not copy it here because it is too long and boring, but in short, it says that source code is what the developer writes.
It is text, readable, and ChatGPT also lists a lot of things that can characterize source code, but they have nothing to do with the essence.

****
The most important trait of the source code is that it is edited by humans.
****




〔section Conclusion and Takeaway〕
