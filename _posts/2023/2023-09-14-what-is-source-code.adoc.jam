---
{%@define title=What is source code?%}
title: {%title%}
layout: posta
comments: on
---
{%@import javax0.jim%}
{%@comment

=========================================================================================
%}
{%@sep 〔〕%}
= 〔title〕

〔section Introduction〕

This article is about the definition of source code.
Usually, this is straightforward, and there is no need for contemplating on this topic.
Everybody knows what source code is.
In some special cases, however, we may get confused and knowing what we are really doing may help avoid mistake.
This is not a philosophical article.
There is merit in knowing and understanding some of the rules we follow and to know when we deliberately break these rules and face the consequences.

〔section The story behind the issue〕

In a project, we started to use GitLab and the CI/CD features of it.
The description of the tasks should be given in a YAML file ``.gitlab-ci.yml``.
We realized that the task descriptions, managing versions are redundant.
They may appear elsewhere in the project, and we have to keep them in sync.

I suggested to the team that we should use a single source of truth.
To do that, we could use a Kotlin DSL file and use Gradle build to generate the YAML file.

This solution would work, but it is not a clean solution.
What is the problem with it?

The problem is that it generates a file that describes the process, which indeed includes the generation of this description file.
It is like a snake biting its tail.

In practice, it works.
You can run the build on the developer machine, generate the YAML file, and then commit it to the repository along with the other source files.
In this case, however, there is a mandatory part of the build running on the developer machine.
It is against the idea of CI/CD that the build in its entirety should be run on the CI/CD server.

The compromise I also applied in the Java::Geci project is that the

* the tool is treated as a "personal productivity tool", like an editor running on the developer machine, and

* the same tool is used as a "test tool" that is run on the CI/CD server.

When running on the developer machine as a standalone tool or as part of the build process, it will generate the CI/CD YAML.
When running on the CI/CD server, it will check that the YAML file is up-to-date.
If the build life cycle contains the regeneration and comparison of the CI/CD YAML during the test phase, the standard test failure signals can be used to fail and stop a build.
If the generated Yaml file is the same as the one already there, the build is dandy.
If it is different, the build fails.

On the developer machine, the build can interactively be restarted.
On the CI/CD server, the failure is a hard failure.
This way the generated code is partially treated as source code.

Is this a clean solution?
No, it is not.
It violates the principle that the build should be the same on the developer machine and on the CI/CD server.
It also violates the principle that the testing and the tested system should be separated.
A system cannot test itself, or some part of it.
Since the CI/CD YAML is part of the system, it should not run a test on itself.
If the test fails, it is a clear signal of some error.
On the other hand, if there is no error, it may mean

* we are dandy, or
* there is an error in the testing system, which is also the tested system.

It is a workaround making the build process more complicated.
Is it worth doing it?
One should decide on a case-by-case basis.

What would be the clean solution?
I will answer that question at the end of this article in the takeaway section, but to get there and to understand the reasoning behind it, we have to go through some almost philosophical contemplation.

What we have to answer is the following:

〔section What is source code?〕

The problem with this question is that it is too simple.
We all know what source code is.

It is like asking about the sun.
What is the sun?
Everybody knows what the sun is, and still, researchers are investigating it every day with huge budgets.

The same is true for source code.
We work with source code every day.
It rises from the keyboard at the start of the day and sets in the compiler after commit.
It is the text file we edit, send to the compiler, store in version control databases, and so on.

What the source code does not usually do is controlling the execution of something.
It goes to the compiler, and the compiler generates the executable.

``.gitlab-ci.yml`` however does.
It is a source code and "executable" at the same time.
It is edited by the developer, stored in the version control.
It behaves like a source code, therefore, it is source code.
It is used to control the execution of the CI/CD process.
It behaves as a (non-machine code) executable, therefore, it is executable.

This dual nature of the file is the reason for the issue.

〔section Reason〕

What is the reason for the issue?

I cannot be absolutely certain, because I did not design the architecture of the GitLab pipeline engine.
My guess is that the engineers considered different approaches and selected one that is the most efficient.

The clean solution would be to have the definition of the build process somewhere else and not in the source repository.
For the build process, this description is an executable, therefore, it has nothing to do with the source repository.
Where could it be stored?
It could be stored in a separate "data store".
Reading the previous sentence again considering that in this case, the "data store" can be anything, it is clear that the obvious choice is a repository.
It can be something like a Maven repository, Ivy repository, or any other repository that stores artifacts.
It can even be a Git repository, which would be an obvious choice for GitLab.

One could maintain the build describing ``.gitlab-ci.yml`` file in one repository as a source code.
If it is maintained using a DSL, then the DLS file is the source code, and this repo has its own, presumably much simpler ``.gitlab-ci.yml``.
The build process described in it would generate the target ``.gitlab-ci.yml`` and the last step would release and deploy it to the repository from where the CI/CD engine of the "real" project would read it.

Why don't we have this clean solution?
Because it is way too complex.
People can go long miles manually editing redundant text file before deciding to insert another step into the development process.

Every step is an abstraction, a layer of indirection, and a new script and process to maintain.
99% of the cases, it is not worth it.

〔section Conclusion and Takeaway〕


